"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.<defprolog> (V913) (let Result (let Parse_shen.<predicate*> (shen.<predicate*> V913) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.prolog-error (V920 V921) (cond ((and (cons? V921) (and (cons? (tl V921)) (= () (tl (tl V921))))) (simple-error (cn "prolog syntax error in " (shen.app V920 (cn " here:

 " (shen.app (shen.next-50 50 (hd V921)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V920 "
" shen.a))))))

(defun shen.next-50 (V926 V927) (cond ((= () V927) "") ((= 0 V926) "") ((cons? V927) (cn (shen.decons-string (hd V927)) (shen.next-50 (- V926 1) (tl V927)))) (true (shen.sys-error shen.next-50))))

(defun shen.decons-string (V928) (cond ((and (cons? V928) (and (= cons (hd V928)) (and (cons? (tl V928)) (and (cons? (tl (tl V928))) (= () (tl (tl (tl V928)))))))) (shen.app (shen.eval-cons V928) " " shen.s)) (true (shen.app V928 " " shen.r))))

(defun shen.insert-predicate (V929 V930) (cond ((and (cons? V930) (and (cons? (tl V930)) (= () (tl (tl V930))))) (cons (cons V929 (hd V930)) (cons :- (tl V930)))) (true (shen.sys-error shen.insert-predicate))))

(defun shen.<predicate*> (V935) (let Result (if (cons? (hd V935)) (let Parse_X (hd (hd V935)) (shen.pair (hd (shen.pair (tl (hd V935)) (shen.hdtl V935))) Parse_X)) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<clauses*> (V940) (let Result (let Parse_shen.<clause*> (shen.<clause*> V940) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V940) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<clause*> (V945) (let Result (let Parse_shen.<head*> (shen.<head*> V945) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<head*> (V950) (let Result (let Parse_shen.<term*> (shen.<term*> V950) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V950) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<term*> (V955) (let Result (if (cons? (hd V955)) (let Parse_X (hd (hd V955)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V955)) (shen.hdtl V955))) (shen.eval-cons Parse_X)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.legitimate-term? (V960) (cond ((and (cons? V960) (and (= cons (hd V960)) (and (cons? (tl V960)) (and (cons? (tl (tl V960))) (= () (tl (tl (tl V960)))))))) (and (shen.legitimate-term? (hd (tl V960))) (shen.legitimate-term? (hd (tl (tl V960)))))) ((and (cons? V960) (and (= mode (hd V960)) (and (cons? (tl V960)) (and (cons? (tl (tl V960))) (and (= + (hd (tl (tl V960)))) (= () (tl (tl (tl V960))))))))) (shen.legitimate-term? (hd (tl V960)))) ((and (cons? V960) (and (= mode (hd V960)) (and (cons? (tl V960)) (and (cons? (tl (tl V960))) (and (= - (hd (tl (tl V960)))) (= () (tl (tl (tl V960))))))))) (shen.legitimate-term? (hd (tl V960)))) ((cons? V960) false) (true true)))

(defun shen.eval-cons (V961) (cond ((and (cons? V961) (and (= cons (hd V961)) (and (cons? (tl V961)) (and (cons? (tl (tl V961))) (= () (tl (tl (tl V961)))))))) (cons (shen.eval-cons (hd (tl V961))) (shen.eval-cons (hd (tl (tl V961)))))) ((and (cons? V961) (and (= mode (hd V961)) (and (cons? (tl V961)) (and (cons? (tl (tl V961))) (= () (tl (tl (tl V961)))))))) (cons mode (cons (shen.eval-cons (hd (tl V961))) (tl (tl V961))))) (true V961)))

(defun shen.<body*> (V966) (let Result (let Parse_shen.<literal*> (shen.<literal*> V966) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V966) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<literal*> (V971) (let Result (if (and (cons? (hd V971)) (= ! (hd (hd V971)))) (shen.pair (hd (shen.pair (tl (hd V971)) (shen.hdtl V971))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= Result (fail)) (let Result (if (cons? (hd V971)) (let Parse_X (hd (hd V971)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V971)) (shen.hdtl V971))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<end*> (V976) (let Result (if (cons? (hd V976)) (let Parse_X (hd (hd V976)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V976)) (shen.hdtl V976))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun cut (V977 V978 V979) (let Result (thaw V979) (if (= Result false) V977 Result)))

(defun shen.insert_modes (V980) (cond ((and (cons? V980) (and (= mode (hd V980)) (and (cons? (tl V980)) (and (cons? (tl (tl V980))) (= () (tl (tl (tl V980)))))))) V980) ((= () V980) ()) ((cons? V980) (cons (cons mode (cons (hd V980) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V980)) (cons - ()))))) (true V980)))

(defun shen.s-prolog (V981) (map (lambda V907 (eval V907)) (shen.prolog->shen V981)))

(defun shen.prolog->shen (V982) (map shen.compile_prolog_procedure (shen.group_clauses (map shen.s-prolog_clause (mapcan shen.head_abstraction V982)))))

(defun shen.s-prolog_clause (V983) (cond ((and (cons? V983) (and (cons? (tl V983)) (and (= :- (hd (tl V983))) (and (cons? (tl (tl V983))) (= () (tl (tl (tl V983)))))))) (cons (hd V983) (cons :- (cons (map shen.s-prolog_literal (hd (tl (tl V983)))) ())))) (true (shen.sys-error shen.s-prolog_clause))))

(defun shen.head_abstraction (V984) (cond ((and (cons? V984) (and (cons? (tl V984)) (and (= :- (hd (tl V984))) (and (cons? (tl (tl V984))) (and (= () (tl (tl (tl V984)))) (< (shen.complexity_head (hd V984)) (value shen.*maxcomplexity*))))))) (cons V984 ())) ((and (cons? V984) (and (cons? (hd V984)) (and (cons? (tl V984)) (and (= :- (hd (tl V984))) (and (cons? (tl (tl V984))) (= () (tl (tl (tl V984))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V984))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V984)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V984)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V984)))) ()))) (cons Clause ())))))) (true (shen.sys-error shen.head_abstraction))))

(defun shen.complexity_head (V989) (cond ((cons? V989) (shen.product (map shen.complexity (tl V989)))) (true (shen.sys-error shen.complexity_head))))

(defun shen.complexity (V997) (cond ((and (cons? V997) (and (= mode (hd V997)) (and (cons? (tl V997)) (and (cons? (hd (tl V997))) (and (= mode (hd (hd (tl V997)))) (and (cons? (tl (hd (tl V997)))) (and (cons? (tl (tl (hd (tl V997))))) (and (= () (tl (tl (tl (hd (tl V997)))))) (and (cons? (tl (tl V997))) (= () (tl (tl (tl V997))))))))))))) (shen.complexity (hd (tl V997)))) ((and (cons? V997) (and (= mode (hd V997)) (and (cons? (tl V997)) (and (cons? (hd (tl V997))) (and (cons? (tl (tl V997))) (and (= + (hd (tl (tl V997)))) (= () (tl (tl (tl V997)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V997))) (tl (tl V997))))) (shen.complexity (cons mode (cons (tl (hd (tl V997))) (tl (tl V997)))))))) ((and (cons? V997) (and (= mode (hd V997)) (and (cons? (tl V997)) (and (cons? (hd (tl V997))) (and (cons? (tl (tl V997))) (and (= - (hd (tl (tl V997)))) (= () (tl (tl (tl V997)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V997))) (tl (tl V997))))) (shen.complexity (cons mode (cons (tl (hd (tl V997))) (tl (tl V997))))))) ((and (cons? V997) (and (= mode (hd V997)) (and (cons? (tl V997)) (and (cons? (tl (tl V997))) (and (= () (tl (tl (tl V997)))) (variable? (hd (tl V997)))))))) 1) ((and (cons? V997) (and (= mode (hd V997)) (and (cons? (tl V997)) (and (cons? (tl (tl V997))) (and (= + (hd (tl (tl V997)))) (= () (tl (tl (tl V997))))))))) 2) ((and (cons? V997) (and (= mode (hd V997)) (and (cons? (tl V997)) (and (cons? (tl (tl V997))) (and (= - (hd (tl (tl V997)))) (= () (tl (tl (tl V997))))))))) 1) (true (shen.complexity (cons mode (cons V997 (cons + ())))))))

(defun shen.product (V998) (cond ((= () V998) 1) ((cons? V998) (* (hd V998) (shen.product (tl V998)))) (true (shen.sys-error shen.product))))

(defun shen.s-prolog_literal (V999) (cond ((and (cons? V999) (and (= is (hd V999)) (and (cons? (tl V999)) (and (cons? (tl (tl V999))) (= () (tl (tl (tl V999)))))))) (cons bind (cons (hd (tl V999)) (cons (shen.insert_deref (hd (tl (tl V999)))) ())))) ((and (cons? V999) (and (= when (hd V999)) (and (cons? (tl V999)) (= () (tl (tl V999)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V999))) ()))) ((and (cons? V999) (and (= bind (hd V999)) (and (cons? (tl V999)) (and (cons? (tl (tl V999))) (= () (tl (tl (tl V999)))))))) (cons bind (cons (hd (tl V999)) (cons (shen.insert_lazyderef (hd (tl (tl V999)))) ())))) ((and (cons? V999) (and (= fwhen (hd V999)) (and (cons? (tl V999)) (= () (tl (tl V999)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V999))) ()))) ((cons? V999) (cons (shen.m_prolog_to_s-prolog_predicate (hd V999)) (tl V999))) (true (shen.sys-error shen.s-prolog_literal))))

(defun shen.insert_deref (V1000) (cond ((variable? V1000) (cons shen.deref (cons V1000 (cons ProcessN ())))) ((cons? V1000) (cons (shen.insert_deref (hd V1000)) (shen.insert_deref (tl V1000)))) (true V1000)))

(defun shen.insert_lazyderef (V1001) (cond ((variable? V1001) (cons shen.lazyderef (cons V1001 (cons ProcessN ())))) ((cons? V1001) (cons (shen.insert_lazyderef (hd V1001)) (shen.insert_lazyderef (tl V1001)))) (true V1001)))

(defun shen.m_prolog_to_s-prolog_predicate (V1002) (cond ((= = V1002) unify) ((= =! V1002) unify!) ((= == V1002) identical) (true V1002)))

(defun shen.group_clauses (V1003) (cond ((= () V1003) ()) ((cons? V1003) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V1003) X)) V1003) (let Rest (difference V1003 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.sys-error shen.group_clauses))))

(defun shen.collect (V1006 V1007) (cond ((= () V1007) ()) ((cons? V1007) (if (V1006 (hd V1007)) (cons (hd V1007) (shen.collect V1006 (tl V1007))) (shen.collect V1006 (tl V1007)))) (true (shen.sys-error shen.collect))))

(defun shen.same_predicate? (V1024 V1025) (cond ((and (cons? V1024) (and (cons? (hd V1024)) (and (cons? V1025) (cons? (hd V1025))))) (= (hd (hd V1024)) (hd (hd V1025)))) (true (shen.sys-error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V1026) (let F (shen.procedure_name V1026) (let Shen (shen.clauses-to-shen F V1026) Shen)))

(defun shen.procedure_name (V1039) (cond ((and (cons? V1039) (and (cons? (hd V1039)) (cons? (hd (hd V1039))))) (hd (hd (hd V1039)))) (true (shen.sys-error shen.procedure_name))))

(defun shen.clauses-to-shen (V1040 V1041) (let Linear (map shen.linearise-clause V1041) (let Arity (shen.prolog-aritycheck V1040 (map (lambda V908 (head V908)) V1041)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map shen.aum_to_shen AUM_instructions))) (let ShenDef (cons define (cons V1040 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V1042) (cond ((not (shen.occurs? cut V1042)) V1042) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V1042 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1047 V1048) (cond ((= V1048 V1047) false) (true V1048)))

(defun shen.nest-disjunct (V1050) (cond ((and (cons? V1050) (= () (tl V1050))) (hd V1050)) ((cons? V1050) (shen.lisp-or (hd V1050) (shen.nest-disjunct (tl V1050)))) (true (shen.sys-error shen.nest-disjunct))))

(defun shen.lisp-or (V1051 V1052) (cons let (cons Case (cons V1051 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1052 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1055 V1056) (cond ((and (cons? V1056) (= () (tl V1056))) (- (length (hd V1056)) 1)) ((and (cons? V1056) (cons? (tl V1056))) (if (= (length (hd V1056)) (length (hd (tl V1056)))) (shen.prolog-aritycheck V1055 (tl V1056)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1055 ()) "
" shen.a))))) (true (shen.sys-error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1057) (cond ((and (cons? V1057) (and (cons? (tl V1057)) (and (= :- (hd (tl V1057))) (and (cons? (tl (tl V1057))) (= () (tl (tl (tl V1057)))))))) (let Linear (shen.linearise (cons (hd V1057) (tl (tl V1057)))) (shen.clause_form Linear))) (true (shen.sys-error shen.linearise-clause))))

(defun shen.clause_form (V1058) (cond ((and (cons? V1058) (and (cons? (tl V1058)) (= () (tl (tl V1058))))) (cons (shen.explicit_modes (hd V1058)) (cons :- (cons (shen.cf_help (hd (tl V1058))) ())))) (true (shen.sys-error shen.clause_form))))

(defun shen.explicit_modes (V1059) (cond ((cons? V1059) (cons (hd V1059) (map shen.em_help (tl V1059)))) (true (shen.sys-error shen.explicit_modes))))

(defun shen.em_help (V1060) (cond ((and (cons? V1060) (and (= mode (hd V1060)) (and (cons? (tl V1060)) (and (cons? (tl (tl V1060))) (= () (tl (tl (tl V1060)))))))) V1060) (true (cons mode (cons V1060 (cons + ()))))))

(defun shen.cf_help (V1061) (cond ((and (cons? V1061) (and (= where (hd V1061)) (and (cons? (tl V1061)) (and (cons? (hd (tl V1061))) (and (= = (hd (hd (tl V1061)))) (and (cons? (tl (hd (tl V1061)))) (and (cons? (tl (tl (hd (tl V1061))))) (and (= () (tl (tl (tl (hd (tl V1061)))))) (and (cons? (tl (tl V1061))) (= () (tl (tl (tl V1061))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1061)))) (shen.cf_help (hd (tl (tl V1061)))))) (true V1061)))

(defun occurs-check (V1066) (cond ((= + V1066) (set shen.*occurs* true)) ((= - V1066) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1067 V1068) (cond ((and (cons? V1067) (and (cons? (hd V1067)) (and (cons? (tl V1067)) (and (= :- (hd (tl V1067))) (and (cons? (tl (tl V1067))) (= () (tl (tl (tl V1067))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1067)) (cons (shen.continuation_call (tl (hd V1067)) (hd (tl (tl V1067)))) ()))) V1068) (shen.mu_reduction MuApplication +))) (true (shen.sys-error shen.aum))))

(defun shen.continuation_call (V1069 V1070) (let VTerms (cons ProcessN (shen.extract_vars V1069)) (let VBody (shen.extract_vars V1070) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1070)))))

(defun remove (V1071 V1072) (shen.remove-h V1071 V1072 ()))

(defun shen.remove-h (V1075 V1076 V1077) (cond ((= () V1076) (reverse V1077)) ((and (cons? V1076) (= (hd V1076) V1075)) (shen.remove-h (hd V1076) (tl V1076) V1077)) ((cons? V1076) (shen.remove-h V1075 (tl V1076) (cons (hd V1076) V1077))) (true (shen.sys-error shen.remove-h))))

(defun shen.cc_help (V1079 V1080) (cond ((and (= () V1079) (= () V1080)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1080) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1079 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1079) (cons call (cons shen.the (cons shen.continuation (cons V1080 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1079 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1080 ())))) ())))))))))))

(defun shen.make_mu_application (V1081 V1082) (cond ((and (cons? V1081) (and (= shen.mu (hd V1081)) (and (cons? (tl V1081)) (and (= () (hd (tl V1081))) (and (cons? (tl (tl V1081))) (and (= () (tl (tl (tl V1081)))) (= () V1082))))))) (hd (tl (tl V1081)))) ((and (cons? V1081) (and (= shen.mu (hd V1081)) (and (cons? (tl V1081)) (and (cons? (hd (tl V1081))) (and (cons? (tl (tl V1081))) (and (= () (tl (tl (tl V1081)))) (cons? V1082))))))) (cons (cons shen.mu (cons (hd (hd (tl V1081))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1081))) (tl (tl V1081)))) (tl V1082)) ()))) (cons (hd V1082) ()))) (true (shen.sys-error shen.make_mu_application))))

(defun shen.mu_reduction (V1089 V1090) (cond ((and (cons? V1089) (and (cons? (hd V1089)) (and (= shen.mu (hd (hd V1089))) (and (cons? (tl (hd V1089))) (and (cons? (hd (tl (hd V1089)))) (and (= mode (hd (hd (tl (hd V1089))))) (and (cons? (tl (hd (tl (hd V1089))))) (and (cons? (tl (tl (hd (tl (hd V1089)))))) (and (= () (tl (tl (tl (hd (tl (hd V1089))))))) (and (cons? (tl (tl (hd V1089)))) (and (= () (tl (tl (tl (hd V1089))))) (and (cons? (tl V1089)) (= () (tl (tl V1089))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1089))))) (tl (tl (hd V1089))))) (tl V1089)) (hd (tl (tl (hd (tl (hd V1089)))))))) ((and (cons? V1089) (and (cons? (hd V1089)) (and (= shen.mu (hd (hd V1089))) (and (cons? (tl (hd V1089))) (and (cons? (tl (tl (hd V1089)))) (and (= () (tl (tl (tl (hd V1089))))) (and (cons? (tl V1089)) (and (= () (tl (tl V1089))) (= _ (hd (tl (hd V1089)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1089)))) V1090)) ((and (cons? V1089) (and (cons? (hd V1089)) (and (= shen.mu (hd (hd V1089))) (and (cons? (tl (hd V1089))) (and (cons? (tl (tl (hd V1089)))) (and (= () (tl (tl (tl (hd V1089))))) (and (cons? (tl V1089)) (and (= () (tl (tl V1089))) (shen.ephemeral_variable? (hd (tl (hd V1089))) (hd (tl V1089))))))))))) (subst (hd (tl V1089)) (hd (tl (hd V1089))) (shen.mu_reduction (hd (tl (tl (hd V1089)))) V1090))) ((and (cons? V1089) (and (cons? (hd V1089)) (and (= shen.mu (hd (hd V1089))) (and (cons? (tl (hd V1089))) (and (cons? (tl (tl (hd V1089)))) (and (= () (tl (tl (tl (hd V1089))))) (and (cons? (tl V1089)) (and (= () (tl (tl V1089))) (variable? (hd (tl (hd V1089)))))))))))) (cons let (cons (hd (tl (hd V1089))) (cons shen.be (cons (hd (tl V1089)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1089)))) V1090) ()))))))) ((and (cons? V1089) (and (cons? (hd V1089)) (and (= shen.mu (hd (hd V1089))) (and (cons? (tl (hd V1089))) (and (cons? (tl (tl (hd V1089)))) (and (= () (tl (tl (tl (hd V1089))))) (and (cons? (tl V1089)) (and (= () (tl (tl V1089))) (and (= - V1090) (shen.prolog_constant? (hd (tl (hd V1089))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1089))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1089))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1089)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1089) (and (cons? (hd V1089)) (and (= shen.mu (hd (hd V1089))) (and (cons? (tl (hd V1089))) (and (cons? (tl (tl (hd V1089)))) (and (= () (tl (tl (tl (hd V1089))))) (and (cons? (tl V1089)) (and (= () (tl (tl V1089))) (and (= + V1090) (shen.prolog_constant? (hd (tl (hd V1089))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1089))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1089))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1089)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1089))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1089)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1089) (and (cons? (hd V1089)) (and (= shen.mu (hd (hd V1089))) (and (cons? (tl (hd V1089))) (and (cons? (hd (tl (hd V1089)))) (and (cons? (tl (tl (hd V1089)))) (and (= () (tl (tl (tl (hd V1089))))) (and (cons? (tl V1089)) (and (= () (tl (tl V1089))) (= - V1090)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1089))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1089)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1089)))) (tl (tl (hd V1089))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1089) (and (cons? (hd V1089)) (and (= shen.mu (hd (hd V1089))) (and (cons? (tl (hd V1089))) (and (cons? (hd (tl (hd V1089)))) (and (cons? (tl (tl (hd V1089)))) (and (= () (tl (tl (tl (hd V1089))))) (and (cons? (tl V1089)) (and (= () (tl (tl V1089))) (= + V1090)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1089))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1089)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1089)))) (tl (tl (hd V1089))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1089)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1089))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1089)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1089)))

(defun shen.rcons_form (V1091) (cond ((cons? V1091) (cons cons (cons (shen.rcons_form (hd V1091)) (cons (shen.rcons_form (tl V1091)) ())))) (true V1091)))

(defun shen.remove_modes (V1092) (cond ((and (cons? V1092) (and (= mode (hd V1092)) (and (cons? (tl V1092)) (and (cons? (tl (tl V1092))) (and (= + (hd (tl (tl V1092)))) (= () (tl (tl (tl V1092))))))))) (shen.remove_modes (hd (tl V1092)))) ((and (cons? V1092) (and (= mode (hd V1092)) (and (cons? (tl V1092)) (and (cons? (tl (tl V1092))) (and (= - (hd (tl (tl V1092)))) (= () (tl (tl (tl V1092))))))))) (shen.remove_modes (hd (tl V1092)))) ((cons? V1092) (cons (shen.remove_modes (hd V1092)) (shen.remove_modes (tl V1092)))) (true V1092)))

(defun shen.ephemeral_variable? (V1093 V1094) (and (variable? V1093) (variable? V1094)))

(defun shen.prolog_constant? (V1103) (cond ((cons? V1103) false) (true true)))

(defun shen.aum_to_shen (V1104) (cond ((and (cons? V1104) (and (= let (hd V1104)) (and (cons? (tl V1104)) (and (cons? (tl (tl V1104))) (and (= shen.be (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (and (cons? (tl (tl (tl (tl V1104))))) (and (= in (hd (tl (tl (tl (tl V1104)))))) (and (cons? (tl (tl (tl (tl (tl V1104)))))) (= () (tl (tl (tl (tl (tl (tl V1104)))))))))))))))) (cons let (cons (hd (tl V1104)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1104))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1104))))))) ()))))) ((and (cons? V1104) (and (= shen.the (hd V1104)) (and (cons? (tl V1104)) (and (= shen.result (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= shen.of (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (and (= shen.dereferencing (hd (tl (tl (tl V1104))))) (and (cons? (tl (tl (tl (tl V1104))))) (= () (tl (tl (tl (tl (tl V1104))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1104)))))) (cons ProcessN ())))) ((and (cons? V1104) (and (= if (hd V1104)) (and (cons? (tl V1104)) (and (cons? (tl (tl V1104))) (and (= shen.then (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (and (cons? (tl (tl (tl (tl V1104))))) (and (= shen.else (hd (tl (tl (tl (tl V1104)))))) (and (cons? (tl (tl (tl (tl (tl V1104)))))) (= () (tl (tl (tl (tl (tl (tl V1104)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1104))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1104))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1104))))))) ()))))) ((and (cons? V1104) (and (cons? (tl V1104)) (and (= is (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= shen.a (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (and (= shen.variable (hd (tl (tl (tl V1104))))) (= () (tl (tl (tl (tl V1104)))))))))))) (cons shen.pvar? (cons (hd V1104) ()))) ((and (cons? V1104) (and (cons? (tl V1104)) (and (= is (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= shen.a (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (and (= shen.non-empty (hd (tl (tl (tl V1104))))) (and (cons? (tl (tl (tl (tl V1104))))) (and (= list (hd (tl (tl (tl (tl V1104)))))) (= () (tl (tl (tl (tl (tl V1104))))))))))))))) (cons cons? (cons (hd V1104) ()))) ((and (cons? V1104) (and (= shen.rename (hd V1104)) (and (cons? (tl V1104)) (and (= shen.the (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= shen.variables (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (and (= in (hd (tl (tl (tl V1104))))) (and (cons? (tl (tl (tl (tl V1104))))) (and (= () (hd (tl (tl (tl (tl V1104)))))) (and (cons? (tl (tl (tl (tl (tl V1104)))))) (and (= and (hd (tl (tl (tl (tl (tl V1104))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1104))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1104)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1104)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1104)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1104)))))))))) ((and (cons? V1104) (and (= shen.rename (hd V1104)) (and (cons? (tl V1104)) (and (= shen.the (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= shen.variables (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (and (= in (hd (tl (tl (tl V1104))))) (and (cons? (tl (tl (tl (tl V1104))))) (and (cons? (hd (tl (tl (tl (tl V1104)))))) (and (cons? (tl (tl (tl (tl (tl V1104)))))) (and (= and (hd (tl (tl (tl (tl (tl V1104))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1104))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1104)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1104)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1104)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1104)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1104)))))) (tl (tl (tl (tl (tl V1104))))))))))) ()))))) ((and (cons? V1104) (and (= bind (hd V1104)) (and (cons? (tl V1104)) (and (cons? (tl (tl V1104))) (and (= shen.to (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (and (cons? (tl (tl (tl (tl V1104))))) (and (= in (hd (tl (tl (tl (tl V1104)))))) (and (cons? (tl (tl (tl (tl (tl V1104)))))) (= () (tl (tl (tl (tl (tl (tl V1104)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1104)) (cons (shen.chwild (hd (tl (tl (tl V1104))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1104))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1104)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1104) (and (cons? (tl V1104)) (and (= is (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= identical (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (and (= shen.to (hd (tl (tl (tl V1104))))) (and (cons? (tl (tl (tl (tl V1104))))) (= () (tl (tl (tl (tl (tl V1104)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1104))))) (cons (hd V1104) ())))) ((= shen.failed! V1104) false) ((and (cons? V1104) (and (= shen.the (hd V1104)) (and (cons? (tl V1104)) (and (= head (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= shen.of (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (= () (tl (tl (tl (tl V1104)))))))))))) (cons hd (tl (tl (tl V1104))))) ((and (cons? V1104) (and (= shen.the (hd V1104)) (and (cons? (tl V1104)) (and (= tail (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= shen.of (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (= () (tl (tl (tl (tl V1104)))))))))))) (cons tl (tl (tl (tl V1104))))) ((and (cons? V1104) (and (= shen.pop (hd V1104)) (and (cons? (tl V1104)) (and (= shen.the (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= shen.stack (hd (tl (tl V1104)))) (= () (tl (tl (tl V1104)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1104) (and (= call (hd V1104)) (and (cons? (tl V1104)) (and (= shen.the (hd (tl V1104))) (and (cons? (tl (tl V1104))) (and (= shen.continuation (hd (tl (tl V1104)))) (and (cons? (tl (tl (tl V1104)))) (= () (tl (tl (tl (tl V1104)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1104))))) ProcessN Continuation) ())))) (true V1104)))

(defun shen.chwild (V1105) (cond ((= V1105 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1105) (map shen.chwild V1105)) (true V1105)))

(defun shen.newpv (V1106) (let Count+1 (+ (<-address (value shen.*varcounter*) V1106) 1) (let IncVar (address-> (value shen.*varcounter*) V1106 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1106) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1106 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1107 V1108) (let Vector (<-address (value shen.*prologvectors*) V1107) (let BigVector (shen.resize-vector Vector (+ V1108 V1108) shen.-null-) (address-> (value shen.*prologvectors*) V1107 BigVector))))

(defun shen.resize-vector (V1109 V1110 V1111) (let BigVector (address-> (absvector (+ 1 V1110)) 0 V1110) (shen.copy-vector V1109 BigVector (limit V1109) V1110 V1111)))

(defun shen.copy-vector (V1112 V1113 V1114 V1115 V1116) (shen.copy-vector-stage-2 (+ 1 V1114) (+ V1115 1) V1116 (shen.copy-vector-stage-1 1 V1112 V1113 (+ 1 V1114))))

(defun shen.copy-vector-stage-1 (V1119 V1120 V1121 V1122) (cond ((= V1122 V1119) V1121) (true (shen.copy-vector-stage-1 (+ 1 V1119) V1120 (address-> V1121 V1119 (<-address V1120 V1119)) V1122))))

(defun shen.copy-vector-stage-2 (V1126 V1127 V1128 V1129) (cond ((= V1127 V1126) V1129) (true (shen.copy-vector-stage-2 (+ V1126 1) V1127 V1128 (address-> V1129 V1126 V1128)))))

(defun shen.mk-pvar (V1131) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1131))

(defun shen.pvar? (V1132) (and (absvector? V1132) (= (<-address V1132 0) shen.pvar)))

(defun shen.bindv (V1133 V1134 V1135) (let Vector (<-address (value shen.*prologvectors*) V1135) (address-> Vector (<-address V1133 1) V1134)))

(defun shen.unbindv (V1136 V1137) (let Vector (<-address (value shen.*prologvectors*) V1137) (address-> Vector (<-address V1136 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1138 V1139 V1140) (cond ((and (cons? V1138) (and (cons? (hd V1138)) (= () (tl V1138)))) (cons (hd (hd V1138)) (append (tl (hd V1138)) (cons V1139 (cons V1140 ()))))) ((and (cons? V1138) (cons? (hd V1138))) (let NewContinuation (shen.newcontinuation (tl V1138) V1139 V1140) (cons (hd (hd V1138)) (append (tl (hd V1138)) (cons V1139 (cons NewContinuation ())))))) (true (shen.sys-error shen.call_the_continuation))))

(defun shen.newcontinuation (V1141 V1142 V1143) (cond ((= () V1141) V1143) ((and (cons? V1141) (cons? (hd V1141))) (cons freeze (cons (cons (hd (hd V1141)) (append (tl (hd V1141)) (cons V1142 (cons (shen.newcontinuation (tl V1141) V1142 V1143) ())))) ()))) (true (shen.sys-error shen.newcontinuation))))

(defun return (V1148 V1149 V1150) (shen.deref V1148 V1149))

(defun shen.measure&return (V1155 V1156 V1157) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1155 V1156)))

(defun unify (V1158 V1159 V1160 V1161) (shen.lzy= (shen.lazyderef V1158 V1160) (shen.lazyderef V1159 V1160) V1160 V1161))

(defun shen.lzy= (V1178 V1179 V1180 V1181) (cond ((= V1179 V1178) (thaw V1181)) ((shen.pvar? V1178) (bind V1178 V1179 V1180 V1181)) ((shen.pvar? V1179) (bind V1179 V1178 V1180 V1181)) ((and (cons? V1178) (cons? V1179)) (shen.lzy= (shen.lazyderef (hd V1178) V1180) (shen.lazyderef (hd V1179) V1180) V1180 (freeze (shen.lzy= (shen.lazyderef (tl V1178) V1180) (shen.lazyderef (tl V1179) V1180) V1180 V1181)))) (true false)))

(defun shen.deref (V1183 V1184) (cond ((cons? V1183) (cons (shen.deref (hd V1183) V1184) (shen.deref (tl V1183) V1184))) (true (if (shen.pvar? V1183) (let Value (shen.valvector V1183 V1184) (if (= Value shen.-null-) V1183 (shen.deref Value V1184))) V1183))))

(defun shen.lazyderef (V1185 V1186) (if (shen.pvar? V1185) (let Value (shen.valvector V1185 V1186) (if (= Value shen.-null-) V1185 (shen.lazyderef Value V1186))) V1185))

(defun shen.valvector (V1187 V1188) (<-address (<-address (value shen.*prologvectors*) V1188) (<-address V1187 1)))

(defun unify! (V1189 V1190 V1191 V1192) (shen.lzy=! (shen.lazyderef V1189 V1191) (shen.lazyderef V1190 V1191) V1191 V1192))

(defun shen.lzy=! (V1209 V1210 V1211 V1212) (cond ((= V1210 V1209) (thaw V1212)) ((and (shen.pvar? V1209) (not (shen.occurs? V1209 (shen.deref V1210 V1211)))) (bind V1209 V1210 V1211 V1212)) ((and (shen.pvar? V1210) (not (shen.occurs? V1210 (shen.deref V1209 V1211)))) (bind V1210 V1209 V1211 V1212)) ((and (cons? V1209) (cons? V1210)) (shen.lzy=! (shen.lazyderef (hd V1209) V1211) (shen.lazyderef (hd V1210) V1211) V1211 (freeze (shen.lzy=! (shen.lazyderef (tl V1209) V1211) (shen.lazyderef (tl V1210) V1211) V1211 V1212)))) (true false)))

(defun shen.occurs? (V1222 V1223) (cond ((= V1223 V1222) true) ((cons? V1223) (or (shen.occurs? V1222 (hd V1223)) (shen.occurs? V1222 (tl V1223)))) (true false)))

(defun identical (V1225 V1226 V1227 V1228) (shen.lzy== (shen.lazyderef V1225 V1227) (shen.lazyderef V1226 V1227) V1227 V1228))

(defun shen.lzy== (V1245 V1246 V1247 V1248) (cond ((= V1246 V1245) (thaw V1248)) ((and (cons? V1245) (cons? V1246)) (shen.lzy== (shen.lazyderef (hd V1245) V1247) (shen.lazyderef (hd V1246) V1247) V1247 (freeze (shen.lzy== (tl V1245) (tl V1246) V1247 V1248)))) (true false)))

(defun shen.pvar (V1250) (cn "Var" (shen.app (<-address V1250 1) "" shen.a)))

(defun bind (V1251 V1252 V1253 V1254) (do (shen.bindv V1251 V1252 V1253) (let Result (thaw V1254) (do (shen.unbindv V1251 V1253) Result))))

(defun fwhen (V1269 V1270 V1271) (cond ((= true V1269) (thaw V1271)) ((= false V1269) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V1269 "%" shen.s))))))

(defun call (V1284 V1285 V1286) (cond ((cons? V1284) (shen.call-help (shen.m_prolog_to_s-prolog_predicate (shen.lazyderef (hd V1284) V1285)) (tl V1284) V1285 V1286)) (true false)))

(defun shen.call-help (V1287 V1288 V1289 V1290) (cond ((= () V1288) (V1287 V1289 V1290)) ((cons? V1288) (shen.call-help (V1287 (hd V1288)) (tl V1288) V1289 V1290)) (true (shen.sys-error shen.call-help))))

(defun shen.intprolog (V1291) (cond ((and (cons? V1291) (cons? (hd V1291))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V1291)) (shen.insert-prolog-variables (cons (tl (hd V1291)) (cons (tl V1291) ())) ProcessN) ProcessN))) (true (shen.sys-error shen.intprolog))))

(defun shen.intprolog-help (V1292 V1293 V1294) (cond ((and (cons? V1293) (and (cons? (tl V1293)) (= () (tl (tl V1293))))) (shen.intprolog-help-help V1292 (hd V1293) (hd (tl V1293)) V1294)) (true (shen.sys-error shen.intprolog-help))))

(defun shen.intprolog-help-help (V1295 V1296 V1297 V1298) (cond ((= () V1296) (V1295 V1298 (freeze (shen.call-rest V1297 V1298)))) ((cons? V1296) (shen.intprolog-help-help (V1295 (hd V1296)) (tl V1296) V1297 V1298)) (true (shen.sys-error shen.intprolog-help-help))))

(defun shen.call-rest (V1301 V1302) (cond ((= () V1301) true) ((and (cons? V1301) (and (cons? (hd V1301)) (cons? (tl (hd V1301))))) (shen.call-rest (cons (cons ((hd (hd V1301)) (hd (tl (hd V1301)))) (tl (tl (hd V1301)))) (tl V1301)) V1302)) ((and (cons? V1301) (and (cons? (hd V1301)) (= () (tl (hd V1301))))) ((hd (hd V1301)) V1302 (freeze (shen.call-rest (tl V1301) V1302)))) (true (shen.sys-error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V1303 V1304) (shen.insert-prolog-variables-help V1303 (shen.flatten V1303) V1304))

(defun shen.insert-prolog-variables-help (V1309 V1310 V1311) (cond ((= () V1310) V1309) ((and (cons? V1310) (variable? (hd V1310))) (let V (shen.newpv V1311) (let XV/Y (subst V (hd V1310) V1309) (let Z-Y (remove (hd V1310) (tl V1310)) (shen.insert-prolog-variables-help XV/Y Z-Y V1311))))) ((cons? V1310) (shen.insert-prolog-variables-help V1309 (tl V1310) V1311)) (true (shen.sys-error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V1312) (let Vector (address-> (value shen.*prologvectors*) V1312 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V1312 1) V1312)))



