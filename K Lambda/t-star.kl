"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2826 V2827) (let Curry (shen.curry V2826) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2827)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2828) (cond ((and (cons? V2828) (shen.special? (hd V2828))) (cons (hd V2828) (map shen.curry (tl V2828)))) ((and (cons? V2828) (and (cons? (tl V2828)) (shen.extraspecial? (hd V2828)))) V2828) ((and (cons? V2828) (and (= type (hd V2828)) (and (cons? (tl V2828)) (and (cons? (tl (tl V2828))) (= () (tl (tl (tl V2828)))))))) (cons type (cons (shen.curry (hd (tl V2828))) (tl (tl V2828))))) ((and (cons? V2828) (and (cons? (tl V2828)) (cons? (tl (tl V2828))))) (shen.curry (cons (cons (hd V2828) (cons (hd (tl V2828)) ())) (tl (tl V2828))))) ((and (cons? V2828) (and (cons? (tl V2828)) (= () (tl (tl V2828))))) (cons (shen.curry (hd V2828)) (cons (shen.curry (hd (tl V2828))) ()))) (true V2828)))

(defun shen.special? (V2829) (element? V2829 (value shen.*special*)))

(defun shen.extraspecial? (V2830) (element? V2830 (value shen.*extraspecial*)))

(defun shen.t* (V2831 V2832 V2833 V2834) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2833) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2833 (freeze (bind Error (shen.errormaxinfs) V2833 V2834))))) (if (= Case false) (let Case (let V2820 (shen.lazyderef V2831 V2833) (if (= fail V2820) (do (shen.incinfs) (cut Throwcontrol V2833 (freeze (shen.prolog-failure V2833 V2834)))) false)) (if (= Case false) (let Case (let V2821 (shen.lazyderef V2831 V2833) (if (cons? V2821) (let X (hd V2821) (let V2822 (shen.lazyderef (tl V2821) V2833) (if (cons? V2822) (let V2823 (shen.lazyderef (hd V2822) V2833) (if (= : V2823) (let V2824 (shen.lazyderef (tl V2822) V2833) (if (cons? V2824) (let A (hd V2824) (let V2825 (shen.lazyderef (tl V2824) V2833) (if (= () V2825) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2833 (freeze (cut Throwcontrol V2833 (freeze (shen.th* X A V2832 V2833 V2834)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2833) (do (shen.incinfs) (shen.show V2831 V2832 V2833 (freeze (bind Datatypes (value shen.*datatypes*) V2833 (freeze (shen.udefs* V2831 V2832 Datatypes V2833 V2834))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2839) (cond ((= + V2839) (set shen.*shen-type-theory-enabled?* true)) ((= - V2839) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2848 V2849) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2850 V2851 V2852 V2853 V2854) (let Case (let V2816 (shen.lazyderef V2852 V2853) (if (cons? V2816) (let D (hd V2816) (do (shen.incinfs) (call (cons D (cons V2850 (cons V2851 ()))) V2853 V2854))) false)) (if (= Case false) (let V2817 (shen.lazyderef V2852 V2853) (if (cons? V2817) (let Ds (tl V2817) (do (shen.incinfs) (shen.udefs* V2850 V2851 Ds V2853 V2854))) false)) Case)))

(defun shen.th* (V2855 V2856 V2857 V2858 V2859) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2855 (cons : (cons V2856 ()))) V2857 V2858 (freeze (fwhen false V2858 V2859)))) (if (= Case false) (let Case (let F (shen.newpv V2858) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2855 V2858)) V2858 (freeze (bind F (shen.sigf (shen.lazyderef V2855 V2858)) V2858 (freeze (call (cons F (cons V2856 ())) V2858 V2859))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2855 V2856 V2858 V2859)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2855 V2856 V2857 V2858 V2859)) (if (= Case false) (let Case (let V2701 (shen.lazyderef V2855 V2858) (if (cons? V2701) (let F (hd V2701) (let V2702 (shen.lazyderef (tl V2701) V2858) (if (= () V2702) (do (shen.incinfs) (shen.th* F (cons --> (cons V2856 ())) V2857 V2858 V2859)) false))) false)) (if (= Case false) (let Case (let V2703 (shen.lazyderef V2855 V2858) (if (cons? V2703) (let F (hd V2703) (let V2704 (shen.lazyderef (tl V2703) V2858) (if (cons? V2704) (let X (hd V2704) (let V2705 (shen.lazyderef (tl V2704) V2858) (if (= () V2705) (let B (shen.newpv V2858) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2856 ()))) V2857 V2858 (freeze (shen.th* X B V2857 V2858 V2859))))) false))) false))) false)) (if (= Case false) (let Case (let V2706 (shen.lazyderef V2855 V2858) (if (cons? V2706) (let V2707 (shen.lazyderef (hd V2706) V2858) (if (= cons V2707) (let V2708 (shen.lazyderef (tl V2706) V2858) (if (cons? V2708) (let X (hd V2708) (let V2709 (shen.lazyderef (tl V2708) V2858) (if (cons? V2709) (let Y (hd V2709) (let V2710 (shen.lazyderef (tl V2709) V2858) (if (= () V2710) (let V2711 (shen.lazyderef V2856 V2858) (if (cons? V2711) (let V2712 (shen.lazyderef (hd V2711) V2858) (if (= list V2712) (let V2713 (shen.lazyderef (tl V2711) V2858) (if (cons? V2713) (let A (hd V2713) (let V2714 (shen.lazyderef (tl V2713) V2858) (if (= () V2714) (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons list (cons A ())) V2857 V2858 V2859)))) (if (shen.pvar? V2714) (do (shen.bindv V2714 () V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons list (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2714 V2858) Result))) false)))) (if (shen.pvar? V2713) (let A (shen.newpv V2858) (do (shen.bindv V2713 (cons A ()) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons list (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2713 V2858) Result)))) false))) (if (shen.pvar? V2712) (do (shen.bindv V2712 list V2858) (let Result (let V2715 (shen.lazyderef (tl V2711) V2858) (if (cons? V2715) (let A (hd V2715) (let V2716 (shen.lazyderef (tl V2715) V2858) (if (= () V2716) (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons list (cons A ())) V2857 V2858 V2859)))) (if (shen.pvar? V2716) (do (shen.bindv V2716 () V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons list (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2716 V2858) Result))) false)))) (if (shen.pvar? V2715) (let A (shen.newpv V2858) (do (shen.bindv V2715 (cons A ()) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons list (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2715 V2858) Result)))) false))) (do (shen.unbindv V2712 V2858) Result))) false))) (if (shen.pvar? V2711) (let A (shen.newpv V2858) (do (shen.bindv V2711 (cons list (cons A ())) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons list (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2711 V2858) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2717 (shen.lazyderef V2855 V2858) (if (cons? V2717) (let V2718 (shen.lazyderef (hd V2717) V2858) (if (= @p V2718) (let V2719 (shen.lazyderef (tl V2717) V2858) (if (cons? V2719) (let X (hd V2719) (let V2720 (shen.lazyderef (tl V2719) V2858) (if (cons? V2720) (let Y (hd V2720) (let V2721 (shen.lazyderef (tl V2720) V2858) (if (= () V2721) (let V2722 (shen.lazyderef V2856 V2858) (if (cons? V2722) (let A (hd V2722) (let V2723 (shen.lazyderef (tl V2722) V2858) (if (cons? V2723) (let V2724 (shen.lazyderef (hd V2723) V2858) (if (= * V2724) (let V2725 (shen.lazyderef (tl V2723) V2858) (if (cons? V2725) (let B (hd V2725) (let V2726 (shen.lazyderef (tl V2725) V2858) (if (= () V2726) (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y B V2857 V2858 V2859)))) (if (shen.pvar? V2726) (do (shen.bindv V2726 () V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y B V2857 V2858 V2859)))) (do (shen.unbindv V2726 V2858) Result))) false)))) (if (shen.pvar? V2725) (let B (shen.newpv V2858) (do (shen.bindv V2725 (cons B ()) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y B V2857 V2858 V2859)))) (do (shen.unbindv V2725 V2858) Result)))) false))) (if (shen.pvar? V2724) (do (shen.bindv V2724 * V2858) (let Result (let V2727 (shen.lazyderef (tl V2723) V2858) (if (cons? V2727) (let B (hd V2727) (let V2728 (shen.lazyderef (tl V2727) V2858) (if (= () V2728) (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y B V2857 V2858 V2859)))) (if (shen.pvar? V2728) (do (shen.bindv V2728 () V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y B V2857 V2858 V2859)))) (do (shen.unbindv V2728 V2858) Result))) false)))) (if (shen.pvar? V2727) (let B (shen.newpv V2858) (do (shen.bindv V2727 (cons B ()) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y B V2857 V2858 V2859)))) (do (shen.unbindv V2727 V2858) Result)))) false))) (do (shen.unbindv V2724 V2858) Result))) false))) (if (shen.pvar? V2723) (let B (shen.newpv V2858) (do (shen.bindv V2723 (cons * (cons B ())) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y B V2857 V2858 V2859)))) (do (shen.unbindv V2723 V2858) Result)))) false)))) (if (shen.pvar? V2722) (let A (shen.newpv V2858) (let B (shen.newpv V2858) (do (shen.bindv V2722 (cons A (cons * (cons B ()))) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y B V2857 V2858 V2859)))) (do (shen.unbindv V2722 V2858) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2729 (shen.lazyderef V2855 V2858) (if (cons? V2729) (let V2730 (shen.lazyderef (hd V2729) V2858) (if (= @v V2730) (let V2731 (shen.lazyderef (tl V2729) V2858) (if (cons? V2731) (let X (hd V2731) (let V2732 (shen.lazyderef (tl V2731) V2858) (if (cons? V2732) (let Y (hd V2732) (let V2733 (shen.lazyderef (tl V2732) V2858) (if (= () V2733) (let V2734 (shen.lazyderef V2856 V2858) (if (cons? V2734) (let V2735 (shen.lazyderef (hd V2734) V2858) (if (= vector V2735) (let V2736 (shen.lazyderef (tl V2734) V2858) (if (cons? V2736) (let A (hd V2736) (let V2737 (shen.lazyderef (tl V2736) V2858) (if (= () V2737) (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons vector (cons A ())) V2857 V2858 V2859)))) (if (shen.pvar? V2737) (do (shen.bindv V2737 () V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons vector (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2737 V2858) Result))) false)))) (if (shen.pvar? V2736) (let A (shen.newpv V2858) (do (shen.bindv V2736 (cons A ()) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons vector (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2736 V2858) Result)))) false))) (if (shen.pvar? V2735) (do (shen.bindv V2735 vector V2858) (let Result (let V2738 (shen.lazyderef (tl V2734) V2858) (if (cons? V2738) (let A (hd V2738) (let V2739 (shen.lazyderef (tl V2738) V2858) (if (= () V2739) (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons vector (cons A ())) V2857 V2858 V2859)))) (if (shen.pvar? V2739) (do (shen.bindv V2739 () V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons vector (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2739 V2858) Result))) false)))) (if (shen.pvar? V2738) (let A (shen.newpv V2858) (do (shen.bindv V2738 (cons A ()) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons vector (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2738 V2858) Result)))) false))) (do (shen.unbindv V2735 V2858) Result))) false))) (if (shen.pvar? V2734) (let A (shen.newpv V2858) (do (shen.bindv V2734 (cons vector (cons A ())) V2858) (let Result (do (shen.incinfs) (shen.th* X A V2857 V2858 (freeze (shen.th* Y (cons vector (cons A ())) V2857 V2858 V2859)))) (do (shen.unbindv V2734 V2858) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2740 (shen.lazyderef V2855 V2858) (if (cons? V2740) (let V2741 (shen.lazyderef (hd V2740) V2858) (if (= @s V2741) (let V2742 (shen.lazyderef (tl V2740) V2858) (if (cons? V2742) (let X (hd V2742) (let V2743 (shen.lazyderef (tl V2742) V2858) (if (cons? V2743) (let Y (hd V2743) (let V2744 (shen.lazyderef (tl V2743) V2858) (if (= () V2744) (let V2745 (shen.lazyderef V2856 V2858) (if (= string V2745) (do (shen.incinfs) (shen.th* X string V2857 V2858 (freeze (shen.th* Y string V2857 V2858 V2859)))) (if (shen.pvar? V2745) (do (shen.bindv V2745 string V2858) (let Result (do (shen.incinfs) (shen.th* X string V2857 V2858 (freeze (shen.th* Y string V2857 V2858 V2859)))) (do (shen.unbindv V2745 V2858) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2746 (shen.lazyderef V2855 V2858) (if (cons? V2746) (let V2747 (shen.lazyderef (hd V2746) V2858) (if (= lambda V2747) (let V2748 (shen.lazyderef (tl V2746) V2858) (if (cons? V2748) (let X (hd V2748) (let V2749 (shen.lazyderef (tl V2748) V2858) (if (cons? V2749) (let Y (hd V2749) (let V2750 (shen.lazyderef (tl V2749) V2858) (if (= () V2750) (let V2751 (shen.lazyderef V2856 V2858) (if (cons? V2751) (let A (hd V2751) (let V2752 (shen.lazyderef (tl V2751) V2858) (if (cons? V2752) (let V2753 (shen.lazyderef (hd V2752) V2858) (if (= --> V2753) (let V2754 (shen.lazyderef (tl V2752) V2858) (if (cons? V2754) (let B (hd V2754) (let V2755 (shen.lazyderef (tl V2754) V2858) (if (= () V2755) (let Z (shen.newpv V2858) (let X&& (shen.newpv V2858) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (bind X&& (shen.placeholder) V2858 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2858) (shen.lazyderef X V2858) (shen.lazyderef Y V2858)) V2858 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2857) V2858 V2859)))))))))) (if (shen.pvar? V2755) (do (shen.bindv V2755 () V2858) (let Result (let Z (shen.newpv V2858) (let X&& (shen.newpv V2858) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (bind X&& (shen.placeholder) V2858 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2858) (shen.lazyderef X V2858) (shen.lazyderef Y V2858)) V2858 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2857) V2858 V2859)))))))))) (do (shen.unbindv V2755 V2858) Result))) false)))) (if (shen.pvar? V2754) (let B (shen.newpv V2858) (do (shen.bindv V2754 (cons B ()) V2858) (let Result (let Z (shen.newpv V2858) (let X&& (shen.newpv V2858) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (bind X&& (shen.placeholder) V2858 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2858) (shen.lazyderef X V2858) (shen.lazyderef Y V2858)) V2858 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2857) V2858 V2859)))))))))) (do (shen.unbindv V2754 V2858) Result)))) false))) (if (shen.pvar? V2753) (do (shen.bindv V2753 --> V2858) (let Result (let V2756 (shen.lazyderef (tl V2752) V2858) (if (cons? V2756) (let B (hd V2756) (let V2757 (shen.lazyderef (tl V2756) V2858) (if (= () V2757) (let Z (shen.newpv V2858) (let X&& (shen.newpv V2858) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (bind X&& (shen.placeholder) V2858 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2858) (shen.lazyderef X V2858) (shen.lazyderef Y V2858)) V2858 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2857) V2858 V2859)))))))))) (if (shen.pvar? V2757) (do (shen.bindv V2757 () V2858) (let Result (let Z (shen.newpv V2858) (let X&& (shen.newpv V2858) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (bind X&& (shen.placeholder) V2858 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2858) (shen.lazyderef X V2858) (shen.lazyderef Y V2858)) V2858 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2857) V2858 V2859)))))))))) (do (shen.unbindv V2757 V2858) Result))) false)))) (if (shen.pvar? V2756) (let B (shen.newpv V2858) (do (shen.bindv V2756 (cons B ()) V2858) (let Result (let Z (shen.newpv V2858) (let X&& (shen.newpv V2858) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (bind X&& (shen.placeholder) V2858 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2858) (shen.lazyderef X V2858) (shen.lazyderef Y V2858)) V2858 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2857) V2858 V2859)))))))))) (do (shen.unbindv V2756 V2858) Result)))) false))) (do (shen.unbindv V2753 V2858) Result))) false))) (if (shen.pvar? V2752) (let B (shen.newpv V2858) (do (shen.bindv V2752 (cons --> (cons B ())) V2858) (let Result (let Z (shen.newpv V2858) (let X&& (shen.newpv V2858) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (bind X&& (shen.placeholder) V2858 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2858) (shen.lazyderef X V2858) (shen.lazyderef Y V2858)) V2858 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2857) V2858 V2859)))))))))) (do (shen.unbindv V2752 V2858) Result)))) false)))) (if (shen.pvar? V2751) (let A (shen.newpv V2858) (let B (shen.newpv V2858) (do (shen.bindv V2751 (cons A (cons --> (cons B ()))) V2858) (let Result (let Z (shen.newpv V2858) (let X&& (shen.newpv V2858) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (bind X&& (shen.placeholder) V2858 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2858) (shen.lazyderef X V2858) (shen.lazyderef Y V2858)) V2858 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2857) V2858 V2859)))))))))) (do (shen.unbindv V2751 V2858) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2758 (shen.lazyderef V2855 V2858) (if (cons? V2758) (let V2759 (shen.lazyderef (hd V2758) V2858) (if (= let V2759) (let V2760 (shen.lazyderef (tl V2758) V2858) (if (cons? V2760) (let X (hd V2760) (let V2761 (shen.lazyderef (tl V2760) V2858) (if (cons? V2761) (let Y (hd V2761) (let V2762 (shen.lazyderef (tl V2761) V2858) (if (cons? V2762) (let Z (hd V2762) (let V2763 (shen.lazyderef (tl V2762) V2858) (if (= () V2763) (let W (shen.newpv V2858) (let X&& (shen.newpv V2858) (let B (shen.newpv V2858) (do (shen.incinfs) (shen.th* Y B V2857 V2858 (freeze (bind X&& (shen.placeholder) V2858 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2858) (shen.lazyderef X V2858) (shen.lazyderef Z V2858)) V2858 (freeze (shen.th* W V2856 (cons (cons X&& (cons : (cons B ()))) V2857) V2858 V2859))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2764 (shen.lazyderef V2855 V2858) (if (cons? V2764) (let V2765 (shen.lazyderef (hd V2764) V2858) (if (= open V2765) (let V2766 (shen.lazyderef (tl V2764) V2858) (if (cons? V2766) (let FileName (hd V2766) (let V2767 (shen.lazyderef (tl V2766) V2858) (if (cons? V2767) (let Direction2697 (hd V2767) (let V2768 (shen.lazyderef (tl V2767) V2858) (if (= () V2768) (let V2769 (shen.lazyderef V2856 V2858) (if (cons? V2769) (let V2770 (shen.lazyderef (hd V2769) V2858) (if (= stream V2770) (let V2771 (shen.lazyderef (tl V2769) V2858) (if (cons? V2771) (let Direction (hd V2771) (let V2772 (shen.lazyderef (tl V2771) V2858) (if (= () V2772) (do (shen.incinfs) (unify! Direction Direction2697 V2858 (freeze (cut Throwcontrol V2858 (freeze (shen.th* FileName string V2857 V2858 V2859)))))) (if (shen.pvar? V2772) (do (shen.bindv V2772 () V2858) (let Result (do (shen.incinfs) (unify! Direction Direction2697 V2858 (freeze (cut Throwcontrol V2858 (freeze (shen.th* FileName string V2857 V2858 V2859)))))) (do (shen.unbindv V2772 V2858) Result))) false)))) (if (shen.pvar? V2771) (let Direction (shen.newpv V2858) (do (shen.bindv V2771 (cons Direction ()) V2858) (let Result (do (shen.incinfs) (unify! Direction Direction2697 V2858 (freeze (cut Throwcontrol V2858 (freeze (shen.th* FileName string V2857 V2858 V2859)))))) (do (shen.unbindv V2771 V2858) Result)))) false))) (if (shen.pvar? V2770) (do (shen.bindv V2770 stream V2858) (let Result (let V2773 (shen.lazyderef (tl V2769) V2858) (if (cons? V2773) (let Direction (hd V2773) (let V2774 (shen.lazyderef (tl V2773) V2858) (if (= () V2774) (do (shen.incinfs) (unify! Direction Direction2697 V2858 (freeze (cut Throwcontrol V2858 (freeze (shen.th* FileName string V2857 V2858 V2859)))))) (if (shen.pvar? V2774) (do (shen.bindv V2774 () V2858) (let Result (do (shen.incinfs) (unify! Direction Direction2697 V2858 (freeze (cut Throwcontrol V2858 (freeze (shen.th* FileName string V2857 V2858 V2859)))))) (do (shen.unbindv V2774 V2858) Result))) false)))) (if (shen.pvar? V2773) (let Direction (shen.newpv V2858) (do (shen.bindv V2773 (cons Direction ()) V2858) (let Result (do (shen.incinfs) (unify! Direction Direction2697 V2858 (freeze (cut Throwcontrol V2858 (freeze (shen.th* FileName string V2857 V2858 V2859)))))) (do (shen.unbindv V2773 V2858) Result)))) false))) (do (shen.unbindv V2770 V2858) Result))) false))) (if (shen.pvar? V2769) (let Direction (shen.newpv V2858) (do (shen.bindv V2769 (cons stream (cons Direction ())) V2858) (let Result (do (shen.incinfs) (unify! Direction Direction2697 V2858 (freeze (cut Throwcontrol V2858 (freeze (shen.th* FileName string V2857 V2858 V2859)))))) (do (shen.unbindv V2769 V2858) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2775 (shen.lazyderef V2855 V2858) (if (cons? V2775) (let V2776 (shen.lazyderef (hd V2775) V2858) (if (= type V2776) (let V2777 (shen.lazyderef (tl V2775) V2858) (if (cons? V2777) (let X (hd V2777) (let V2778 (shen.lazyderef (tl V2777) V2858) (if (cons? V2778) (let A (hd V2778) (let V2779 (shen.lazyderef (tl V2778) V2858) (if (= () V2779) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (unify A V2856 V2858 (freeze (shen.th* X A V2857 V2858 V2859)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2780 (shen.lazyderef V2855 V2858) (if (cons? V2780) (let V2781 (shen.lazyderef (hd V2780) V2858) (if (= input+ V2781) (let V2782 (shen.lazyderef (tl V2780) V2858) (if (cons? V2782) (let A (hd V2782) (let V2783 (shen.lazyderef (tl V2782) V2858) (if (cons? V2783) (let Stream (hd V2783) (let V2784 (shen.lazyderef (tl V2783) V2858) (if (= () V2784) (let C (shen.newpv V2858) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2858)) V2858 (freeze (unify V2856 C V2858 (freeze (shen.th* Stream (cons stream (cons in ())) V2857 V2858 V2859))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2785 (shen.lazyderef V2855 V2858) (if (cons? V2785) (let V2786 (shen.lazyderef (hd V2785) V2858) (if (= set V2786) (let V2787 (shen.lazyderef (tl V2785) V2858) (if (cons? V2787) (let Var (hd V2787) (let V2788 (shen.lazyderef (tl V2787) V2858) (if (cons? V2788) (let Val (hd V2788) (let V2789 (shen.lazyderef (tl V2788) V2858) (if (= () V2789) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (shen.th* Var symbol V2857 V2858 (freeze (cut Throwcontrol V2858 (freeze (shen.th* (cons value (cons Var ())) V2856 V2857 V2858 (freeze (shen.th* Val V2856 V2857 V2858 V2859)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2790 (shen.lazyderef V2855 V2858) (if (cons? V2790) (let V2791 (shen.lazyderef (hd V2790) V2858) (if (= shen.<-sem V2791) (let V2792 (shen.lazyderef (tl V2790) V2858) (if (cons? V2792) (let F (hd V2792) (let V2793 (shen.lazyderef (tl V2792) V2858) (if (= () V2793) (let A (shen.newpv V2858) (let F&& (shen.newpv V2858) (let B (shen.newpv V2858) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2857 V2858 (freeze (cut Throwcontrol V2858 (freeze (bind F&& (concat && (shen.lazyderef F V2858)) V2858 (freeze (cut Throwcontrol V2858 (freeze (shen.th* F&& V2856 (cons (cons F&& (cons : (cons B ()))) V2857) V2858 V2859))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2794 (shen.lazyderef V2855 V2858) (if (cons? V2794) (let V2795 (shen.lazyderef (hd V2794) V2858) (if (= fail V2795) (let V2796 (shen.lazyderef (tl V2794) V2858) (if (= () V2796) (let V2797 (shen.lazyderef V2856 V2858) (if (= symbol V2797) (do (shen.incinfs) (thaw V2859)) (if (shen.pvar? V2797) (do (shen.bindv V2797 symbol V2858) (let Result (do (shen.incinfs) (thaw V2859)) (do (shen.unbindv V2797 V2858) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2858) (do (shen.incinfs) (shen.t*-hyps V2857 NewHyp V2858 (freeze (shen.th* V2855 V2856 NewHyp V2858 V2859))))) (if (= Case false) (let Case (let V2798 (shen.lazyderef V2855 V2858) (if (cons? V2798) (let V2799 (shen.lazyderef (hd V2798) V2858) (if (= define V2799) (let V2800 (shen.lazyderef (tl V2798) V2858) (if (cons? V2800) (let F (hd V2800) (let X (tl V2800) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (shen.t*-def (cons define (cons F X)) V2856 V2857 V2858 V2859)))))) false)) false)) false)) (if (= Case false) (let Case (let V2801 (shen.lazyderef V2855 V2858) (if (cons? V2801) (let V2802 (shen.lazyderef (hd V2801) V2858) (if (= defcc V2802) (let V2803 (shen.lazyderef (tl V2801) V2858) (if (cons? V2803) (let F (hd V2803) (let X (tl V2803) (do (shen.incinfs) (cut Throwcontrol V2858 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2856 V2857 V2858 V2859)))))) false)) false)) false)) (if (= Case false) (let Case (let V2804 (shen.lazyderef V2855 V2858) (if (cons? V2804) (let V2805 (shen.lazyderef (hd V2804) V2858) (if (= defmacro V2805) (let V2806 (shen.lazyderef V2856 V2858) (if (= unit V2806) (do (shen.incinfs) (cut Throwcontrol V2858 V2859)) (if (shen.pvar? V2806) (do (shen.bindv V2806 unit V2858) (let Result (do (shen.incinfs) (cut Throwcontrol V2858 V2859)) (do (shen.unbindv V2806 V2858) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2807 (shen.lazyderef V2855 V2858) (if (cons? V2807) (let V2808 (shen.lazyderef (hd V2807) V2858) (if (= shen.process-datatype V2808) (let V2809 (shen.lazyderef V2856 V2858) (if (= symbol V2809) (do (shen.incinfs) (thaw V2859)) (if (shen.pvar? V2809) (do (shen.bindv V2809 symbol V2858) (let Result (do (shen.incinfs) (thaw V2859)) (do (shen.unbindv V2809 V2858) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2810 (shen.lazyderef V2855 V2858) (if (cons? V2810) (let V2811 (shen.lazyderef (hd V2810) V2858) (if (= shen.synonyms-help V2811) (let V2812 (shen.lazyderef V2856 V2858) (if (= symbol V2812) (do (shen.incinfs) (thaw V2859)) (if (shen.pvar? V2812) (do (shen.bindv V2812 symbol V2858) (let Result (do (shen.incinfs) (thaw V2859)) (do (shen.unbindv V2812 V2858) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2858) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2858 (freeze (shen.udefs* (cons V2855 (cons : (cons V2856 ()))) V2857 Datatypes V2858 V2859))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2860 V2861 V2862 V2863) (let Case (let V2612 (shen.lazyderef V2860 V2862) (if (cons? V2612) (let V2613 (shen.lazyderef (hd V2612) V2862) (if (cons? V2613) (let V2614 (shen.lazyderef (hd V2613) V2862) (if (cons? V2614) (let V2615 (shen.lazyderef (hd V2614) V2862) (if (= cons V2615) (let V2616 (shen.lazyderef (tl V2614) V2862) (if (cons? V2616) (let X (hd V2616) (let V2617 (shen.lazyderef (tl V2616) V2862) (if (cons? V2617) (let Y (hd V2617) (let V2618 (shen.lazyderef (tl V2617) V2862) (if (= () V2618) (let V2619 (shen.lazyderef (tl V2613) V2862) (if (cons? V2619) (let V2620 (shen.lazyderef (hd V2619) V2862) (if (= : V2620) (let V2621 (shen.lazyderef (tl V2619) V2862) (if (cons? V2621) (let V2622 (shen.lazyderef (hd V2621) V2862) (if (cons? V2622) (let V2623 (shen.lazyderef (hd V2622) V2862) (if (= list V2623) (let V2624 (shen.lazyderef (tl V2622) V2862) (if (cons? V2624) (let A (hd V2624) (let V2625 (shen.lazyderef (tl V2624) V2862) (if (= () V2625) (let V2626 (shen.lazyderef (tl V2621) V2862) (if (= () V2626) (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2626) (do (shen.bindv V2626 () V2862) (let Result (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2626 V2862) Result))) false))) (if (shen.pvar? V2625) (do (shen.bindv V2625 () V2862) (let Result (let V2627 (shen.lazyderef (tl V2621) V2862) (if (= () V2627) (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2627) (do (shen.bindv V2627 () V2862) (let Result (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2627 V2862) Result))) false))) (do (shen.unbindv V2625 V2862) Result))) false)))) (if (shen.pvar? V2624) (let A (shen.newpv V2862) (do (shen.bindv V2624 (cons A ()) V2862) (let Result (let V2628 (shen.lazyderef (tl V2621) V2862) (if (= () V2628) (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2628) (do (shen.bindv V2628 () V2862) (let Result (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2628 V2862) Result))) false))) (do (shen.unbindv V2624 V2862) Result)))) false))) (if (shen.pvar? V2623) (do (shen.bindv V2623 list V2862) (let Result (let V2629 (shen.lazyderef (tl V2622) V2862) (if (cons? V2629) (let A (hd V2629) (let V2630 (shen.lazyderef (tl V2629) V2862) (if (= () V2630) (let V2631 (shen.lazyderef (tl V2621) V2862) (if (= () V2631) (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2631) (do (shen.bindv V2631 () V2862) (let Result (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2631 V2862) Result))) false))) (if (shen.pvar? V2630) (do (shen.bindv V2630 () V2862) (let Result (let V2632 (shen.lazyderef (tl V2621) V2862) (if (= () V2632) (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2632) (do (shen.bindv V2632 () V2862) (let Result (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2632 V2862) Result))) false))) (do (shen.unbindv V2630 V2862) Result))) false)))) (if (shen.pvar? V2629) (let A (shen.newpv V2862) (do (shen.bindv V2629 (cons A ()) V2862) (let Result (let V2633 (shen.lazyderef (tl V2621) V2862) (if (= () V2633) (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2633) (do (shen.bindv V2633 () V2862) (let Result (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2633 V2862) Result))) false))) (do (shen.unbindv V2629 V2862) Result)))) false))) (do (shen.unbindv V2623 V2862) Result))) false))) (if (shen.pvar? V2622) (let A (shen.newpv V2862) (do (shen.bindv V2622 (cons list (cons A ())) V2862) (let Result (let V2634 (shen.lazyderef (tl V2621) V2862) (if (= () V2634) (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2634) (do (shen.bindv V2634 () V2862) (let Result (let Hyp (tl V2612) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons list (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2634 V2862) Result))) false))) (do (shen.unbindv V2622 V2862) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2635 (shen.lazyderef V2860 V2862) (if (cons? V2635) (let V2636 (shen.lazyderef (hd V2635) V2862) (if (cons? V2636) (let V2637 (shen.lazyderef (hd V2636) V2862) (if (cons? V2637) (let V2638 (shen.lazyderef (hd V2637) V2862) (if (= @p V2638) (let V2639 (shen.lazyderef (tl V2637) V2862) (if (cons? V2639) (let X (hd V2639) (let V2640 (shen.lazyderef (tl V2639) V2862) (if (cons? V2640) (let Y (hd V2640) (let V2641 (shen.lazyderef (tl V2640) V2862) (if (= () V2641) (let V2642 (shen.lazyderef (tl V2636) V2862) (if (cons? V2642) (let V2643 (shen.lazyderef (hd V2642) V2862) (if (= : V2643) (let V2644 (shen.lazyderef (tl V2642) V2862) (if (cons? V2644) (let V2645 (shen.lazyderef (hd V2644) V2862) (if (cons? V2645) (let A (hd V2645) (let V2646 (shen.lazyderef (tl V2645) V2862) (if (cons? V2646) (let V2647 (shen.lazyderef (hd V2646) V2862) (if (= * V2647) (let V2648 (shen.lazyderef (tl V2646) V2862) (if (cons? V2648) (let B (hd V2648) (let V2649 (shen.lazyderef (tl V2648) V2862) (if (= () V2649) (let V2650 (shen.lazyderef (tl V2644) V2862) (if (= () V2650) (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2650) (do (shen.bindv V2650 () V2862) (let Result (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2650 V2862) Result))) false))) (if (shen.pvar? V2649) (do (shen.bindv V2649 () V2862) (let Result (let V2651 (shen.lazyderef (tl V2644) V2862) (if (= () V2651) (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2651) (do (shen.bindv V2651 () V2862) (let Result (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2651 V2862) Result))) false))) (do (shen.unbindv V2649 V2862) Result))) false)))) (if (shen.pvar? V2648) (let B (shen.newpv V2862) (do (shen.bindv V2648 (cons B ()) V2862) (let Result (let V2652 (shen.lazyderef (tl V2644) V2862) (if (= () V2652) (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2652) (do (shen.bindv V2652 () V2862) (let Result (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2652 V2862) Result))) false))) (do (shen.unbindv V2648 V2862) Result)))) false))) (if (shen.pvar? V2647) (do (shen.bindv V2647 * V2862) (let Result (let V2653 (shen.lazyderef (tl V2646) V2862) (if (cons? V2653) (let B (hd V2653) (let V2654 (shen.lazyderef (tl V2653) V2862) (if (= () V2654) (let V2655 (shen.lazyderef (tl V2644) V2862) (if (= () V2655) (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2655) (do (shen.bindv V2655 () V2862) (let Result (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2655 V2862) Result))) false))) (if (shen.pvar? V2654) (do (shen.bindv V2654 () V2862) (let Result (let V2656 (shen.lazyderef (tl V2644) V2862) (if (= () V2656) (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2656) (do (shen.bindv V2656 () V2862) (let Result (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2656 V2862) Result))) false))) (do (shen.unbindv V2654 V2862) Result))) false)))) (if (shen.pvar? V2653) (let B (shen.newpv V2862) (do (shen.bindv V2653 (cons B ()) V2862) (let Result (let V2657 (shen.lazyderef (tl V2644) V2862) (if (= () V2657) (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2657) (do (shen.bindv V2657 () V2862) (let Result (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2657 V2862) Result))) false))) (do (shen.unbindv V2653 V2862) Result)))) false))) (do (shen.unbindv V2647 V2862) Result))) false))) (if (shen.pvar? V2646) (let B (shen.newpv V2862) (do (shen.bindv V2646 (cons * (cons B ())) V2862) (let Result (let V2658 (shen.lazyderef (tl V2644) V2862) (if (= () V2658) (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2658) (do (shen.bindv V2658 () V2862) (let Result (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2658 V2862) Result))) false))) (do (shen.unbindv V2646 V2862) Result)))) false)))) (if (shen.pvar? V2645) (let A (shen.newpv V2862) (let B (shen.newpv V2862) (do (shen.bindv V2645 (cons A (cons * (cons B ()))) V2862) (let Result (let V2659 (shen.lazyderef (tl V2644) V2862) (if (= () V2659) (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2659) (do (shen.bindv V2659 () V2862) (let Result (let Hyp (tl V2635) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (shen.lazyderef B V2862) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2659 V2862) Result))) false))) (do (shen.unbindv V2645 V2862) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2660 (shen.lazyderef V2860 V2862) (if (cons? V2660) (let V2661 (shen.lazyderef (hd V2660) V2862) (if (cons? V2661) (let V2662 (shen.lazyderef (hd V2661) V2862) (if (cons? V2662) (let V2663 (shen.lazyderef (hd V2662) V2862) (if (= @v V2663) (let V2664 (shen.lazyderef (tl V2662) V2862) (if (cons? V2664) (let X (hd V2664) (let V2665 (shen.lazyderef (tl V2664) V2862) (if (cons? V2665) (let Y (hd V2665) (let V2666 (shen.lazyderef (tl V2665) V2862) (if (= () V2666) (let V2667 (shen.lazyderef (tl V2661) V2862) (if (cons? V2667) (let V2668 (shen.lazyderef (hd V2667) V2862) (if (= : V2668) (let V2669 (shen.lazyderef (tl V2667) V2862) (if (cons? V2669) (let V2670 (shen.lazyderef (hd V2669) V2862) (if (cons? V2670) (let V2671 (shen.lazyderef (hd V2670) V2862) (if (= vector V2671) (let V2672 (shen.lazyderef (tl V2670) V2862) (if (cons? V2672) (let A (hd V2672) (let V2673 (shen.lazyderef (tl V2672) V2862) (if (= () V2673) (let V2674 (shen.lazyderef (tl V2669) V2862) (if (= () V2674) (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2674) (do (shen.bindv V2674 () V2862) (let Result (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2674 V2862) Result))) false))) (if (shen.pvar? V2673) (do (shen.bindv V2673 () V2862) (let Result (let V2675 (shen.lazyderef (tl V2669) V2862) (if (= () V2675) (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2675) (do (shen.bindv V2675 () V2862) (let Result (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2675 V2862) Result))) false))) (do (shen.unbindv V2673 V2862) Result))) false)))) (if (shen.pvar? V2672) (let A (shen.newpv V2862) (do (shen.bindv V2672 (cons A ()) V2862) (let Result (let V2676 (shen.lazyderef (tl V2669) V2862) (if (= () V2676) (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2676) (do (shen.bindv V2676 () V2862) (let Result (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2676 V2862) Result))) false))) (do (shen.unbindv V2672 V2862) Result)))) false))) (if (shen.pvar? V2671) (do (shen.bindv V2671 vector V2862) (let Result (let V2677 (shen.lazyderef (tl V2670) V2862) (if (cons? V2677) (let A (hd V2677) (let V2678 (shen.lazyderef (tl V2677) V2862) (if (= () V2678) (let V2679 (shen.lazyderef (tl V2669) V2862) (if (= () V2679) (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2679) (do (shen.bindv V2679 () V2862) (let Result (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2679 V2862) Result))) false))) (if (shen.pvar? V2678) (do (shen.bindv V2678 () V2862) (let Result (let V2680 (shen.lazyderef (tl V2669) V2862) (if (= () V2680) (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2680) (do (shen.bindv V2680 () V2862) (let Result (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2680 V2862) Result))) false))) (do (shen.unbindv V2678 V2862) Result))) false)))) (if (shen.pvar? V2677) (let A (shen.newpv V2862) (do (shen.bindv V2677 (cons A ()) V2862) (let Result (let V2681 (shen.lazyderef (tl V2669) V2862) (if (= () V2681) (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2681) (do (shen.bindv V2681 () V2862) (let Result (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2681 V2862) Result))) false))) (do (shen.unbindv V2677 V2862) Result)))) false))) (do (shen.unbindv V2671 V2862) Result))) false))) (if (shen.pvar? V2670) (let A (shen.newpv V2862) (do (shen.bindv V2670 (cons vector (cons A ())) V2862) (let Result (let V2682 (shen.lazyderef (tl V2669) V2862) (if (= () V2682) (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2682) (do (shen.bindv V2682 () V2862) (let Result (let Hyp (tl V2660) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons (shen.lazyderef A V2862) ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons (cons vector (cons (shen.lazyderef A V2862) ())) ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2682 V2862) Result))) false))) (do (shen.unbindv V2670 V2862) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2683 (shen.lazyderef V2860 V2862) (if (cons? V2683) (let V2684 (shen.lazyderef (hd V2683) V2862) (if (cons? V2684) (let V2685 (shen.lazyderef (hd V2684) V2862) (if (cons? V2685) (let V2686 (shen.lazyderef (hd V2685) V2862) (if (= @s V2686) (let V2687 (shen.lazyderef (tl V2685) V2862) (if (cons? V2687) (let X (hd V2687) (let V2688 (shen.lazyderef (tl V2687) V2862) (if (cons? V2688) (let Y (hd V2688) (let V2689 (shen.lazyderef (tl V2688) V2862) (if (= () V2689) (let V2690 (shen.lazyderef (tl V2684) V2862) (if (cons? V2690) (let V2691 (shen.lazyderef (hd V2690) V2862) (if (= : V2691) (let V2692 (shen.lazyderef (tl V2690) V2862) (if (cons? V2692) (let V2693 (shen.lazyderef (hd V2692) V2862) (if (= string V2693) (let V2694 (shen.lazyderef (tl V2692) V2862) (if (= () V2694) (let Hyp (tl V2683) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons string ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2694) (do (shen.bindv V2694 () V2862) (let Result (let Hyp (tl V2683) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons string ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2694 V2862) Result))) false))) (if (shen.pvar? V2693) (do (shen.bindv V2693 string V2862) (let Result (let V2695 (shen.lazyderef (tl V2692) V2862) (if (= () V2695) (let Hyp (tl V2683) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons string ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (if (shen.pvar? V2695) (do (shen.bindv V2695 () V2862) (let Result (let Hyp (tl V2683) (do (shen.incinfs) (bind V2861 (cons (cons (shen.lazyderef X V2862) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2862) (cons : (cons string ()))) (shen.lazyderef Hyp V2862))) V2862 V2863))) (do (shen.unbindv V2695 V2862) Result))) false))) (do (shen.unbindv V2693 V2862) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2696 (shen.lazyderef V2860 V2862) (if (cons? V2696) (let X (hd V2696) (let Hyp (tl V2696) (let NewHyps (shen.newpv V2862) (do (shen.incinfs) (bind V2861 (cons (shen.lazyderef X V2862) (shen.lazyderef NewHyps V2862)) V2862 (freeze (shen.t*-hyps Hyp NewHyps V2862 V2863))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2876 V2877 V2878 V2879) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2876 V2878)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2877 V2878) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2879))))))))) (true (thaw V2879))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2880) (cond ((and (cons? V2880) (and (cons? (tl V2880)) (and (= : (hd (tl V2880))) (and (cons? (tl (tl V2880))) (= () (tl (tl (tl V2880)))))))) (shen.prhush (shen.app (hd V2880) (cn " : " (shen.app (hd (tl (tl V2880))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2880 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2883 V2884) (cond ((= () V2883) shen.skip) ((cons? V2883) (do (shen.prhush (shen.app V2884 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2883)) (do (nl 1) (shen.show-assumptions (tl V2883) (+ V2884 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2885) (cons? (assoc V2885 (value shen.*signedfuncs*))))

(defun shen.sigf (V2886) (concat shen.type-signature-of- V2886))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2887 V2888 V2889 V2890) (let Case (let V2599 (shen.lazyderef V2888 V2889) (if (= number V2599) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2887 V2889)) V2889 V2890)) (if (shen.pvar? V2599) (do (shen.bindv V2599 number V2889) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2887 V2889)) V2889 V2890)) (do (shen.unbindv V2599 V2889) Result))) false))) (if (= Case false) (let Case (let V2600 (shen.lazyderef V2888 V2889) (if (= boolean V2600) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2887 V2889)) V2889 V2890)) (if (shen.pvar? V2600) (do (shen.bindv V2600 boolean V2889) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2887 V2889)) V2889 V2890)) (do (shen.unbindv V2600 V2889) Result))) false))) (if (= Case false) (let Case (let V2601 (shen.lazyderef V2888 V2889) (if (= string V2601) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2887 V2889)) V2889 V2890)) (if (shen.pvar? V2601) (do (shen.bindv V2601 string V2889) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2887 V2889)) V2889 V2890)) (do (shen.unbindv V2601 V2889) Result))) false))) (if (= Case false) (let Case (let V2602 (shen.lazyderef V2888 V2889) (if (= symbol V2602) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2887 V2889)) V2889 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2887 V2889))) V2889 V2890)))) (if (shen.pvar? V2602) (do (shen.bindv V2602 symbol V2889) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2887 V2889)) V2889 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2887 V2889))) V2889 V2890)))) (do (shen.unbindv V2602 V2889) Result))) false))) (if (= Case false) (let V2603 (shen.lazyderef V2887 V2889) (if (= () V2603) (let V2604 (shen.lazyderef V2888 V2889) (if (cons? V2604) (let V2605 (shen.lazyderef (hd V2604) V2889) (if (= list V2605) (let V2606 (shen.lazyderef (tl V2604) V2889) (if (cons? V2606) (let A (hd V2606) (let V2607 (shen.lazyderef (tl V2606) V2889) (if (= () V2607) (do (shen.incinfs) (thaw V2890)) (if (shen.pvar? V2607) (do (shen.bindv V2607 () V2889) (let Result (do (shen.incinfs) (thaw V2890)) (do (shen.unbindv V2607 V2889) Result))) false)))) (if (shen.pvar? V2606) (let A (shen.newpv V2889) (do (shen.bindv V2606 (cons A ()) V2889) (let Result (do (shen.incinfs) (thaw V2890)) (do (shen.unbindv V2606 V2889) Result)))) false))) (if (shen.pvar? V2605) (do (shen.bindv V2605 list V2889) (let Result (let V2608 (shen.lazyderef (tl V2604) V2889) (if (cons? V2608) (let A (hd V2608) (let V2609 (shen.lazyderef (tl V2608) V2889) (if (= () V2609) (do (shen.incinfs) (thaw V2890)) (if (shen.pvar? V2609) (do (shen.bindv V2609 () V2889) (let Result (do (shen.incinfs) (thaw V2890)) (do (shen.unbindv V2609 V2889) Result))) false)))) (if (shen.pvar? V2608) (let A (shen.newpv V2889) (do (shen.bindv V2608 (cons A ()) V2889) (let Result (do (shen.incinfs) (thaw V2890)) (do (shen.unbindv V2608 V2889) Result)))) false))) (do (shen.unbindv V2605 V2889) Result))) false))) (if (shen.pvar? V2604) (let A (shen.newpv V2889) (do (shen.bindv V2604 (cons list (cons A ())) V2889) (let Result (do (shen.incinfs) (thaw V2890)) (do (shen.unbindv V2604 V2889) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2891 V2892 V2893 V2894 V2895) (let Case (let V2590 (shen.lazyderef V2893 V2894) (if (cons? V2590) (let V2591 (shen.lazyderef (hd V2590) V2894) (if (cons? V2591) (let Y (hd V2591) (let V2592 (shen.lazyderef (tl V2591) V2894) (if (cons? V2592) (let V2593 (shen.lazyderef (hd V2592) V2894) (if (= : V2593) (let V2594 (shen.lazyderef (tl V2592) V2894) (if (cons? V2594) (let B (hd V2594) (let V2595 (shen.lazyderef (tl V2594) V2894) (if (= () V2595) (do (shen.incinfs) (identical V2891 Y V2894 (freeze (unify! V2892 B V2894 V2895)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2596 (shen.lazyderef V2893 V2894) (if (cons? V2596) (let Hyp (tl V2596) (do (shen.incinfs) (shen.by_hypothesis V2891 V2892 Hyp V2894 V2895))) false)) Case)))

(defun shen.t*-def (V2896 V2897 V2898 V2899 V2900) (let V2584 (shen.lazyderef V2896 V2899) (if (cons? V2584) (let V2585 (shen.lazyderef (hd V2584) V2899) (if (= define V2585) (let V2586 (shen.lazyderef (tl V2584) V2899) (if (cons? V2586) (let F (hd V2586) (let X (tl V2586) (let E (shen.newpv V2899) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2897 V2898 V2899 V2900))))) false)) false)) false)))

(defun shen.t*-defh (V2901 V2902 V2903 V2904 V2905 V2906) (let V2580 (shen.lazyderef V2901 V2905) (if (cons? V2580) (let Sig (hd V2580) (let Rules (tl V2580) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2902 V2903 V2904 Rules V2905 V2906)))) false)))

(defun shen.t*-defhh (V2907 V2908 V2909 V2910 V2911 V2912 V2913 V2914) (do (shen.incinfs) (shen.t*-rules V2912 V2908 1 V2909 (cons (cons V2909 (cons : (cons V2908 ()))) V2911) V2913 (freeze (shen.memo V2909 V2907 V2910 V2913 V2914)))))

(defun shen.memo (V2915 V2916 V2917 V2918 V2919) (let Jnk (shen.newpv V2918) (do (shen.incinfs) (unify! V2917 V2916 V2918 (freeze (bind Jnk (declare (shen.lazyderef V2915 V2918) (shen.lazyderef V2917 V2918)) V2918 V2919))))))

(defun shen.<sig+rules> (V2924) (let Result (let Parse_shen.<signature> (shen.<signature> V2924) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2925) (cond ((and (cons? V2925) (and (cons? (tl V2925)) (and (= () (tl (tl V2925))) (= (hd V2925) protect)))) V2925) ((cons? V2925) (map shen.ue V2925)) ((variable? V2925) (concat && V2925)) (true V2925)))

(defun shen.ue-sig (V2926) (cond ((cons? V2926) (map shen.ue-sig V2926)) ((variable? V2926) (concat &&& V2926)) (true V2926)))

(defun shen.ues (V2931) (cond ((shen.ue? V2931) (cons V2931 ())) ((cons? V2931) (union (shen.ues (hd V2931)) (shen.ues (tl V2931)))) (true ())))

(defun shen.ue? (V2932) (and (symbol? V2932) (shen.ue-h? (str V2932))))

(defun shen.ue-h? (V2939) (cond ((and (shen.+string? V2939) (and (= "&" (pos V2939 0)) (and (shen.+string? (tlstr V2939)) (= "&" (pos (tlstr V2939) 0))))) true) (true false)))

(defun shen.t*-rules (V2940 V2941 V2942 V2943 V2944 V2945 V2946) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2555 (shen.lazyderef V2940 V2945) (if (= () V2555) (do (shen.incinfs) (thaw V2946)) false)) (if (= Case false) (let Case (let V2556 (shen.lazyderef V2940 V2945) (if (cons? V2556) (let V2557 (shen.lazyderef (hd V2556) V2945) (if (cons? V2557) (let V2558 (shen.lazyderef (hd V2557) V2945) (if (= () V2558) (let V2559 (shen.lazyderef (tl V2557) V2945) (if (cons? V2559) (let Action (hd V2559) (let V2560 (shen.lazyderef (tl V2559) V2945) (if (= () V2560) (let Rules (tl V2556) (let V2561 (shen.lazyderef V2941 V2945) (if (cons? V2561) (let V2562 (shen.lazyderef (hd V2561) V2945) (if (= --> V2562) (let V2563 (shen.lazyderef (tl V2561) V2945) (if (cons? V2563) (let A (hd V2563) (let V2564 (shen.lazyderef (tl V2563) V2945) (if (= () V2564) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2944 V2945 (freeze (cut Throwcontrol V2945 (freeze (shen.t*-rules Rules A (+ V2942 1) V2943 V2944 V2945 V2946)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2565 (shen.lazyderef V2940 V2945) (if (cons? V2565) (let Rule (hd V2565) (let Rules (tl V2565) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2941 V2944 V2945 (freeze (cut Throwcontrol V2945 (freeze (shen.t*-rules Rules V2941 (+ V2942 1) V2943 V2944 V2945 V2946)))))))) false)) (if (= Case false) (let Err (shen.newpv V2945) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2942 V2945) (cn " of " (shen.app (shen.lazyderef V2943 V2945) "" shen.a)) shen.a))) V2945 V2946))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2947 V2948 V2949 V2950 V2951) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2537 (shen.lazyderef V2947 V2950) (if (cons? V2537) (let V2538 (shen.lazyderef (hd V2537) V2950) (if (= () V2538) (let V2539 (shen.lazyderef (tl V2537) V2950) (if (cons? V2539) (let Action (hd V2539) (let V2540 (shen.lazyderef (tl V2539) V2950) (if (= () V2540) (do (shen.incinfs) (cut Throwcontrol V2950 (freeze (shen.t*-action (shen.curry Action) V2948 V2949 V2950 V2951)))) false))) false)) false)) false)) (if (= Case false) (let V2541 (shen.lazyderef V2947 V2950) (if (cons? V2541) (let V2542 (shen.lazyderef (hd V2541) V2950) (if (cons? V2542) (let Pattern (hd V2542) (let Patterns (tl V2542) (let V2543 (shen.lazyderef (tl V2541) V2950) (if (cons? V2543) (let Action (hd V2543) (let V2544 (shen.lazyderef (tl V2543) V2950) (if (= () V2544) (let V2545 (shen.lazyderef V2948 V2950) (if (cons? V2545) (let A (hd V2545) (let V2546 (shen.lazyderef (tl V2545) V2950) (if (cons? V2546) (let V2547 (shen.lazyderef (hd V2546) V2950) (if (= --> V2547) (let V2548 (shen.lazyderef (tl V2546) V2950) (if (cons? V2548) (let B (hd V2548) (let V2549 (shen.lazyderef (tl V2548) V2950) (if (= () V2549) (do (shen.incinfs) (shen.t*-pattern Pattern A V2950 (freeze (cut Throwcontrol V2950 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2949) V2950 V2951)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2952 V2953 V2954 V2955 V2956) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2514 (shen.lazyderef V2952 V2955) (if (cons? V2514) (let V2515 (shen.lazyderef (hd V2514) V2955) (if (= where V2515) (let V2516 (shen.lazyderef (tl V2514) V2955) (if (cons? V2516) (let P (hd V2516) (let V2517 (shen.lazyderef (tl V2516) V2955) (if (cons? V2517) (let Action (hd V2517) (let V2518 (shen.lazyderef (tl V2517) V2955) (if (= () V2518) (do (shen.incinfs) (cut Throwcontrol V2955 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2954 V2955 (freeze (cut Throwcontrol V2955 (freeze (shen.t*-action Action V2953 (cons (cons P (cons : (cons verified ()))) V2954) V2955 V2956)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2519 (shen.lazyderef V2952 V2955) (if (cons? V2519) (let V2520 (shen.lazyderef (hd V2519) V2955) (if (= shen.choicepoint! V2520) (let V2521 (shen.lazyderef (tl V2519) V2955) (if (cons? V2521) (let V2522 (shen.lazyderef (hd V2521) V2955) (if (cons? V2522) (let V2523 (shen.lazyderef (hd V2522) V2955) (if (cons? V2523) (let V2524 (shen.lazyderef (hd V2523) V2955) (if (= fail-if V2524) (let V2525 (shen.lazyderef (tl V2523) V2955) (if (cons? V2525) (let F (hd V2525) (let V2526 (shen.lazyderef (tl V2525) V2955) (if (= () V2526) (let V2527 (shen.lazyderef (tl V2522) V2955) (if (cons? V2527) (let Action (hd V2527) (let V2528 (shen.lazyderef (tl V2527) V2955) (if (= () V2528) (let V2529 (shen.lazyderef (tl V2521) V2955) (if (= () V2529) (do (shen.incinfs) (cut Throwcontrol V2955 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2953 V2954 V2955 V2956)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2530 (shen.lazyderef V2952 V2955) (if (cons? V2530) (let V2531 (shen.lazyderef (hd V2530) V2955) (if (= shen.choicepoint! V2531) (let V2532 (shen.lazyderef (tl V2530) V2955) (if (cons? V2532) (let Action (hd V2532) (let V2533 (shen.lazyderef (tl V2532) V2955) (if (= () V2533) (do (shen.incinfs) (cut Throwcontrol V2955 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2953 V2954 V2955 V2956)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2952 (cons : (cons V2953 ()))) V2954 V2955 V2956)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2957 V2958 V2959 V2960) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2959) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2957) Hyp V2959 (freeze (cut Throwcontrol V2959 (freeze (shen.t* (cons V2957 (cons : (cons V2958 ()))) Hyp V2959 V2960))))))))))

(defun shen.tms->hyp (V2961 V2962 V2963 V2964) (let Case (let V2498 (shen.lazyderef V2961 V2963) (if (= () V2498) (let V2499 (shen.lazyderef V2962 V2963) (if (= () V2499) (do (shen.incinfs) (thaw V2964)) (if (shen.pvar? V2499) (do (shen.bindv V2499 () V2963) (let Result (do (shen.incinfs) (thaw V2964)) (do (shen.unbindv V2499 V2963) Result))) false))) false)) (if (= Case false) (let V2500 (shen.lazyderef V2961 V2963) (if (cons? V2500) (let Tm2495 (hd V2500) (let Tms (tl V2500) (let V2501 (shen.lazyderef V2962 V2963) (if (cons? V2501) (let V2502 (shen.lazyderef (hd V2501) V2963) (if (cons? V2502) (let Tm (hd V2502) (let V2503 (shen.lazyderef (tl V2502) V2963) (if (cons? V2503) (let V2504 (shen.lazyderef (hd V2503) V2963) (if (= : V2504) (let V2505 (shen.lazyderef (tl V2503) V2963) (if (cons? V2505) (let A (hd V2505) (let V2506 (shen.lazyderef (tl V2505) V2963) (if (= () V2506) (let Hyp (tl V2501) (do (shen.incinfs) (unify! Tm Tm2495 V2963 (freeze (shen.tms->hyp Tms Hyp V2963 V2964))))) (if (shen.pvar? V2506) (do (shen.bindv V2506 () V2963) (let Result (let Hyp (tl V2501) (do (shen.incinfs) (unify! Tm Tm2495 V2963 (freeze (shen.tms->hyp Tms Hyp V2963 V2964))))) (do (shen.unbindv V2506 V2963) Result))) false)))) (if (shen.pvar? V2505) (let A (shen.newpv V2963) (do (shen.bindv V2505 (cons A ()) V2963) (let Result (let Hyp (tl V2501) (do (shen.incinfs) (unify! Tm Tm2495 V2963 (freeze (shen.tms->hyp Tms Hyp V2963 V2964))))) (do (shen.unbindv V2505 V2963) Result)))) false))) (if (shen.pvar? V2504) (do (shen.bindv V2504 : V2963) (let Result (let V2507 (shen.lazyderef (tl V2503) V2963) (if (cons? V2507) (let A (hd V2507) (let V2508 (shen.lazyderef (tl V2507) V2963) (if (= () V2508) (let Hyp (tl V2501) (do (shen.incinfs) (unify! Tm Tm2495 V2963 (freeze (shen.tms->hyp Tms Hyp V2963 V2964))))) (if (shen.pvar? V2508) (do (shen.bindv V2508 () V2963) (let Result (let Hyp (tl V2501) (do (shen.incinfs) (unify! Tm Tm2495 V2963 (freeze (shen.tms->hyp Tms Hyp V2963 V2964))))) (do (shen.unbindv V2508 V2963) Result))) false)))) (if (shen.pvar? V2507) (let A (shen.newpv V2963) (do (shen.bindv V2507 (cons A ()) V2963) (let Result (let Hyp (tl V2501) (do (shen.incinfs) (unify! Tm Tm2495 V2963 (freeze (shen.tms->hyp Tms Hyp V2963 V2964))))) (do (shen.unbindv V2507 V2963) Result)))) false))) (do (shen.unbindv V2504 V2963) Result))) false))) (if (shen.pvar? V2503) (let A (shen.newpv V2963) (do (shen.bindv V2503 (cons : (cons A ())) V2963) (let Result (let Hyp (tl V2501) (do (shen.incinfs) (unify! Tm Tm2495 V2963 (freeze (shen.tms->hyp Tms Hyp V2963 V2964))))) (do (shen.unbindv V2503 V2963) Result)))) false)))) (if (shen.pvar? V2502) (let Tm (shen.newpv V2963) (let A (shen.newpv V2963) (do (shen.bindv V2502 (cons Tm (cons : (cons A ()))) V2963) (let Result (let Hyp (tl V2501) (do (shen.incinfs) (unify! Tm Tm2495 V2963 (freeze (shen.tms->hyp Tms Hyp V2963 V2964))))) (do (shen.unbindv V2502 V2963) Result))))) false))) (if (shen.pvar? V2501) (let Tm (shen.newpv V2963) (let A (shen.newpv V2963) (let Hyp (shen.newpv V2963) (do (shen.bindv V2501 (cons (cons Tm (cons : (cons A ()))) Hyp) V2963) (let Result (do (shen.incinfs) (unify! Tm Tm2495 V2963 (freeze (shen.tms->hyp Tms Hyp V2963 V2964)))) (do (shen.unbindv V2501 V2963) Result)))))) false))))) false)) Case)))

(defun findall (V2965 V2966 V2967 V2968 V2969) (let B (shen.newpv V2968) (let A (shen.newpv V2968) (do (shen.incinfs) (bind A (gensym shen.a) V2968 (freeze (bind B (set (shen.lazyderef A V2968) ()) V2968 (freeze (shen.findallhelp V2965 V2966 V2967 A V2968 V2969)))))))))

(defun shen.findallhelp (V2970 V2971 V2972 V2973 V2974 V2975) (let Case (do (shen.incinfs) (call V2971 V2974 (freeze (shen.remember V2973 V2970 V2974 (freeze (fwhen false V2974 V2975)))))) (if (= Case false) (do (shen.incinfs) (bind V2972 (value (shen.lazyderef V2973 V2974)) V2974 V2975)) Case)))

(defun shen.remember (V2976 V2977 V2978 V2979) (let B (shen.newpv V2978) (do (shen.incinfs) (bind B (set (shen.deref V2976 V2978) (cons (shen.deref V2977 V2978) (value (shen.deref V2976 V2978)))) V2978 V2979))))

(defun shen.t*-defcc (V2980 V2981 V2982 V2983 V2984) (let V2471 (shen.lazyderef V2980 V2983) (if (cons? V2471) (let V2472 (shen.lazyderef (hd V2471) V2983) (if (= defcc V2472) (let V2473 (shen.lazyderef (tl V2471) V2983) (if (cons? V2473) (let F (hd V2473) (let V2474 (shen.lazyderef (tl V2473) V2983) (if (cons? V2474) (let V2475 (shen.lazyderef (hd V2474) V2983) (if (= { V2475) (let V2476 (shen.lazyderef (tl V2474) V2983) (if (cons? V2476) (let V2477 (shen.lazyderef (hd V2476) V2983) (if (cons? V2477) (let V2478 (shen.lazyderef (hd V2477) V2983) (if (= list V2478) (let V2479 (shen.lazyderef (tl V2477) V2983) (if (cons? V2479) (let A (hd V2479) (let V2480 (shen.lazyderef (tl V2479) V2983) (if (= () V2480) (let V2481 (shen.lazyderef (tl V2476) V2983) (if (cons? V2481) (let V2482 (shen.lazyderef (hd V2481) V2983) (if (= ==> V2482) (let V2483 (shen.lazyderef (tl V2481) V2983) (if (cons? V2483) (let B (hd V2483) (let V2484 (shen.lazyderef (tl V2483) V2983) (if (cons? V2484) (let V2485 (shen.lazyderef (hd V2484) V2983) (if (= } V2485) (let Rest (tl V2484) (do (shen.incinfs) (shen.t*-defcc-h (cons defcc (cons F (cons (shen.ue (shen.demodulate (cons (cons list (cons A ())) (cons ==> (cons B ()))))) (shen.ue (shen.split_cc_rules false (shen.plug-wildcards Rest) ()))))) V2981 V2982 V2983 V2984))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))

(defun shen.plug-wildcards (V2985) (cond ((cons? V2985) (map shen.plug-wildcards V2985)) ((= V2985 _) (gensym (intern "X"))) (true V2985)))

(defun shen.t*-defcc-h (V2986 V2987 V2988 V2989 V2990) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2455 (shen.lazyderef V2986 V2989) (if (cons? V2455) (let V2456 (shen.lazyderef (hd V2455) V2989) (if (= defcc V2456) (let V2457 (shen.lazyderef (tl V2455) V2989) (if (cons? V2457) (let F (hd V2457) (let V2458 (shen.lazyderef (tl V2457) V2989) (if (cons? V2458) (let V2459 (shen.lazyderef (hd V2458) V2989) (if (cons? V2459) (let V2460 (shen.lazyderef (hd V2459) V2989) (if (cons? V2460) (let V2461 (shen.lazyderef (hd V2460) V2989) (if (= list V2461) (let V2462 (shen.lazyderef (tl V2460) V2989) (if (cons? V2462) (let A (hd V2462) (let V2463 (shen.lazyderef (tl V2462) V2989) (if (= () V2463) (let V2464 (shen.lazyderef (tl V2459) V2989) (if (cons? V2464) (let V2465 (shen.lazyderef (hd V2464) V2989) (if (= ==> V2465) (let V2466 (shen.lazyderef (tl V2464) V2989) (if (cons? V2466) (let B (hd V2466) (let V2467 (shen.lazyderef (tl V2466) V2989) (if (= () V2467) (let Rules (tl V2458) (let Declare (shen.newpv V2989) (do (shen.incinfs) (cut Throwcontrol V2989 (freeze (shen.tc-rules F Rules (cons list (cons A ())) B (cons (cons F (cons : (cons (cons (cons list (cons A ())) (cons ==> (cons B ()))) ()))) V2988) 1 V2989 (freeze (unify V2987 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2989 (freeze (bind Declare (declare (shen.lazyderef F V2989) (cons (cons list (cons (shen.lazyderef A V2989) ())) (cons ==> (cons (shen.lazyderef B V2989) ())))) V2989 V2990)))))))))) false))) false)) false)) false)) false))) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.tc-rules (V2991 V2992 V2993 V2994 V2995 V2996 V2997 V2998) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2446 (shen.lazyderef V2992 V2997) (if (= () V2446) (do (shen.incinfs) (thaw V2998)) false)) (if (= Case false) (let V2447 (shen.lazyderef V2992 V2997) (if (cons? V2447) (let Rule (hd V2447) (let Rules (tl V2447) (let V2448 (shen.lazyderef V2993 V2997) (if (cons? V2448) (let V2449 (shen.lazyderef (hd V2448) V2997) (if (= list V2449) (let V2450 (shen.lazyderef (tl V2448) V2997) (if (cons? V2450) (let A (hd V2450) (let V2451 (shen.lazyderef (tl V2450) V2997) (if (= () V2451) (let M (shen.newpv V2997) (do (shen.incinfs) (shen.tc-rule V2991 Rule A V2994 V2995 V2996 V2997 (freeze (bind M (+ (shen.deref V2996 V2997) 1) V2997 (freeze (cut Throwcontrol V2997 (freeze (shen.tc-rules V2991 Rules (cons list (cons A ())) V2994 V2995 M V2997 V2998))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V2999 V3000 V3001 V3002 V3003 V3004 V3005 V3006) (let Case (do (shen.incinfs) (shen.check-defcc-rule V3000 V3001 V3002 V3003 V3005 V3006)) (if (= Case false) (let Err (shen.newpv V3005) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3004 V3005) (cn " of " (shen.app (shen.lazyderef V2999 V3005) "" shen.a)) shen.a))) V3005 V3006))) Case)))

(defun shen.check-defcc-rule (V3007 V3008 V3009 V3010 V3011 V3012) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2431 (shen.lazyderef V3007 V3011) (if (cons? V2431) (let Syntax (hd V2431) (let V2432 (shen.lazyderef (tl V2431) V3011) (if (cons? V2432) (let Semantics (hd V2432) (let V2433 (shen.lazyderef (tl V2432) V3011) (if (= () V2433) (let SynHyps (shen.newpv V3011) (do (shen.incinfs) (shen.syntax-hyps Syntax V3010 SynHyps V3008 V3011 (freeze (cut Throwcontrol V3011 (freeze (shen.syntax-check Syntax V3008 SynHyps V3011 (freeze (cut Throwcontrol V3011 (freeze (shen.semantics-check Semantics V3009 SynHyps V3011 V3012))))))))))) false))) false))) false)))))

(defun shen.syntax-hyps (V3013 V3014 V3015 V3016 V3017 V3018) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2416 (shen.lazyderef V3013 V3017) (if (= () V2416) (do (shen.incinfs) (unify! V3015 V3014 V3017 V3018)) false)) (if (= Case false) (let Case (let V2417 (shen.lazyderef V3013 V3017) (if (cons? V2417) (let X2410 (hd V2417) (let Y (tl V2417) (let V2418 (shen.lazyderef V3015 V3017) (if (cons? V2418) (let V2419 (shen.lazyderef (hd V2418) V3017) (if (cons? V2419) (let X (hd V2419) (let V2420 (shen.lazyderef (tl V2419) V3017) (if (cons? V2420) (let V2421 (shen.lazyderef (hd V2420) V3017) (if (= : V2421) (let V2422 (shen.lazyderef (tl V2420) V3017) (if (cons? V2422) (let A2411 (hd V2422) (let V2423 (shen.lazyderef (tl V2422) V3017) (if (= () V2423) (let SynHyps (tl V2418) (do (shen.incinfs) (unify! V3016 A2411 V3017 (freeze (unify! X X2410 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (if (shen.pvar? V2423) (do (shen.bindv V2423 () V3017) (let Result (let SynHyps (tl V2418) (do (shen.incinfs) (unify! V3016 A2411 V3017 (freeze (unify! X X2410 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2423 V3017) Result))) false)))) (if (shen.pvar? V2422) (let A2411 (shen.newpv V3017) (do (shen.bindv V2422 (cons A2411 ()) V3017) (let Result (let SynHyps (tl V2418) (do (shen.incinfs) (unify! V3016 A2411 V3017 (freeze (unify! X X2410 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2422 V3017) Result)))) false))) (if (shen.pvar? V2421) (do (shen.bindv V2421 : V3017) (let Result (let V2424 (shen.lazyderef (tl V2420) V3017) (if (cons? V2424) (let A2411 (hd V2424) (let V2425 (shen.lazyderef (tl V2424) V3017) (if (= () V2425) (let SynHyps (tl V2418) (do (shen.incinfs) (unify! V3016 A2411 V3017 (freeze (unify! X X2410 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (if (shen.pvar? V2425) (do (shen.bindv V2425 () V3017) (let Result (let SynHyps (tl V2418) (do (shen.incinfs) (unify! V3016 A2411 V3017 (freeze (unify! X X2410 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2425 V3017) Result))) false)))) (if (shen.pvar? V2424) (let A2411 (shen.newpv V3017) (do (shen.bindv V2424 (cons A2411 ()) V3017) (let Result (let SynHyps (tl V2418) (do (shen.incinfs) (unify! V3016 A2411 V3017 (freeze (unify! X X2410 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2424 V3017) Result)))) false))) (do (shen.unbindv V2421 V3017) Result))) false))) (if (shen.pvar? V2420) (let A2411 (shen.newpv V3017) (do (shen.bindv V2420 (cons : (cons A2411 ())) V3017) (let Result (let SynHyps (tl V2418) (do (shen.incinfs) (unify! V3016 A2411 V3017 (freeze (unify! X X2410 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2420 V3017) Result)))) false)))) (if (shen.pvar? V2419) (let X (shen.newpv V3017) (let A2411 (shen.newpv V3017) (do (shen.bindv V2419 (cons X (cons : (cons A2411 ()))) V3017) (let Result (let SynHyps (tl V2418) (do (shen.incinfs) (unify! V3016 A2411 V3017 (freeze (unify! X X2410 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2419 V3017) Result))))) false))) (if (shen.pvar? V2418) (let X (shen.newpv V3017) (let A2411 (shen.newpv V3017) (let SynHyps (shen.newpv V3017) (do (shen.bindv V2418 (cons (cons X (cons : (cons A2411 ()))) SynHyps) V3017) (let Result (do (shen.incinfs) (unify! V3016 A2411 V3017 (freeze (unify! X X2410 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018)))))))))) (do (shen.unbindv V2418 V3017) Result)))))) false))))) false)) (if (= Case false) (let V2426 (shen.lazyderef V3013 V3017) (if (cons? V2426) (let Y (tl V2426) (do (shen.incinfs) (shen.syntax-hyps Y V3014 V3015 V3016 V3017 V3018))) false)) Case)) Case)))))

(defun shen.syntax-check (V3019 V3020 V3021 V3022 V3023) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2406 (shen.lazyderef V3019 V3022) (if (= () V2406) (do (shen.incinfs) (thaw V3023)) false)) (if (= Case false) (let Case (let V2407 (shen.lazyderef V3019 V3022) (if (cons? V2407) (let X (hd V2407) (let Syntax (tl V2407) (let C (shen.newpv V3022) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V3022)) V3022 (freeze (cut Throwcontrol V3022 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons V3020 ())) (cons ==> (cons C ()))) ()))) V3021 V3022 (freeze (cut Throwcontrol V3022 (freeze (shen.syntax-check Syntax V3020 V3021 V3022 V3023))))))))))))) false)) (if (= Case false) (let V2408 (shen.lazyderef V3019 V3022) (if (cons? V2408) (let X (hd V2408) (let Syntax (tl V2408) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V3020 ()))) V3021 V3022 (freeze (cut Throwcontrol V3022 (freeze (shen.syntax-check Syntax V3020 V3021 V3022 V3023)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V3024 V3025 V3026 V3027 V3028) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2398 (shen.lazyderef V3024 V3027) (if (cons? V2398) (let V2399 (shen.lazyderef (hd V2398) V3027) (if (= where V2399) (let V2400 (shen.lazyderef (tl V2398) V3027) (if (cons? V2400) (let P (hd V2400) (let V2401 (shen.lazyderef (tl V2400) V3027) (if (cons? V2401) (let Q (hd V2401) (let V2402 (shen.lazyderef (tl V2401) V3027) (if (= () V2402) (do (shen.incinfs) (cut Throwcontrol V3027 (freeze (shen.t* (cons (shen.curry P) (cons : (cons boolean ()))) V3026 V3027 (freeze (shen.t* (cons (shen.curry Q) (cons : (cons V3025 ()))) V3026 V3027 V3028)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Semantics* (shen.newpv V3027) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V3024 V3027))) V3027 (freeze (shen.t* (cons Semantics* (cons : (cons V3025 ()))) V3026 V3027 V3028))))) Case)))))

(defun shen.rename-semantics (V3029) (cond ((cons? V3029) (cons (shen.rename-semantics (hd V3029)) (shen.rename-semantics (tl V3029)))) ((shen.grammar_symbol? V3029) (cons shen.<-sem (cons V3029 ()))) (true V3029)))

"(defprolog syntax-check
  (mode [] -) _ _ <--;
  (mode [X | Syntax] -) A Hyps <-- (fwhen (grammar_symbol? X))
                                   !
                                   (t* [X : [[list B] ==> C]] Hyps)
                                   !
                                   (bind X&& (concat && X))
                                   !
                                   (t* [X&& : [list A]] [[X&& : [list B]] | Hyps]) 
                                   !
                                   (syntax-check Syntax A Hyps);
  (mode [X | Syntax] -) A Hyps <-- (t* [X : A] Hyps)
                                   !
                                   (syntax-check Syntax A Hyps);)"



