
"**********************************************************************************

*                           The License						                                      *

* 										                                                                  *

* The user is free to produce commercial applications with the software, to 	          *

* distribute these applications in source or binary  form, and to charge monies         *

* for them as he sees fit and in concordance with the laws of the land subject 	        *

* to the following license.							                                                *

*										                                                                    * 

* 1. The license applies to all the software and all derived software and 	            *

*    must appear on such.							                                                  *

*										                                                                    *

* 2. It is illegal to distribute the software without this license attached	            *

*    to it and use of the software implies agreement with the license as such.          *

*    It is illegal for anyone who is not the copyright holder to tamper with 	          *

*    or change the license.							                                                *

*										                                                                    *

* 3. Neither the names of Lambda Associates or the copyright holder may be used         *

*    to endorse or promote products built using the software without specific 	        *

*    prior written permission from the copyright holder.		                            *

*										                                                                    *

* 4. That possession of this license does not confer on the copyright holder 	          *

*    any special contractual obligation towards the user. That in no event 	            * 

*    shall the copyright holder be liable for any direct, indirect, incidental,        *   

*    special, exemplary or consequential damages (including but not limited             *

*    to procurement of substitute goods or services, loss of use, data, 	              * 

*    interruption), however caused and on any theory of liability, whether in	          * 

*    contract, strict liability or tort (including negligence) arising in any         	*

*    way out of the use of the software, even if advised of the possibility of         	*

*    such damage.						                                                        		* 

*										                                                                    *

* 5. It is permitted for the user to change the software, for the purpose of 	          *

*    improving performance, correcting an error, or porting to a new platform, 	        *

*    and distribute the derived version of Shen provided the resulting program 	        *

*    conforms in all respects to the Shen standard and is issued under that             * 

*    title. The user must make it clear with his distribution that he/she is 	          *

*    the author of the changes and what these changes are and why. 		                  *

*										                                                                    *

* 6. Derived versions of this software in whatever form are subject to the same         *

*    restrictions. In particular it is not permitted to make derived copies of          *

*    this software which do not conform to the Shen standard or appear under a          *

*    different title.								                                                    *

*										                                                                    *

*    It is permitted to distribute versions of Shen which incorporate libraries,        *

*    graphics or other facilities which are not part of the Shen standard.	            *

*										                                                                    *

* For an explication of this license see www.shenlanguage.org/license.htm which         *

* explains this license in full.                                                        *

*				 						                                                                    *

*****************************************************************************************

"

(DEFUN shen.<defprolog> (V913)
 (LET
  ((Result
    (LET ((Parse_shen.<predicate*> (shen.<predicate*> V913)))
     (IF (NOT (EQ (fail) Parse_shen.<predicate*>))
      (LET ((Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>)))
       (IF (NOT (EQ (fail) Parse_shen.<clauses*>))
        (shen.pair (CAR Parse_shen.<clauses*>)
         (CAR
          (shen.prolog->shen
           (map
            #'(LAMBDA (Parse_X)
               (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>)
                Parse_X))
            (shen.hdtl Parse_shen.<clauses*>)))))
        (fail)))
      (fail)))))
  (IF (EQ Result (fail)) (fail) Result)))

(DEFUN shen.prolog-error (V920 V921)
 (COND
  ((AND (CONSP V921) (AND (CONSP (CDR V921)) (NULL (CDR (CDR V921)))))
   (simple-error
    (cn "prolog syntax error in "
     (shen.app V920
      (cn
       " here:

 "
       (shen.app (shen.next-50 50 (CAR V921))
        "
"
        'shen.a))
      'shen.a))))
  (T
   (simple-error
    (cn "prolog syntax error in "
     (shen.app V920
      "
"
      'shen.a))))))

(DEFUN shen.next-50 (V926 V927)
 (COND ((NULL V927) "") ((shen.ABSEQUAL 0 V926) "")
  ((CONSP V927)
   (cn (shen.decons-string (CAR V927)) (shen.next-50 (1- V926) (CDR V927))))
  (T (shen.sys-error 'shen.next-50))))

(DEFUN shen.decons-string (V928)
 (COND
  ((AND (CONSP V928)
    (AND (EQ 'cons (CAR V928))
     (AND (CONSP (CDR V928))
      (AND (CONSP (CDR (CDR V928))) (NULL (CDR (CDR (CDR V928))))))))
   (shen.app (shen.eval-cons V928) " " 'shen.s))
  (T (shen.app V928 " " 'shen.r))))

(DEFUN shen.insert-predicate (V929 V930)
 (COND
  ((AND (CONSP V930) (AND (CONSP (CDR V930)) (NULL (CDR (CDR V930)))))
   (CONS (CONS V929 (CAR V930)) (CONS '|:-| (CDR V930))))
  (T (shen.sys-error 'shen.insert-predicate))))

(DEFUN shen.<predicate*> (V935)
 (LET
  ((Result
    (IF (CONSP (CAR V935))
     (LET ((Parse_X (CAR (CAR V935))))
      (shen.pair (CAR (shen.pair (CDR (CAR V935)) (shen.hdtl V935))) Parse_X))
     (fail))))
  (IF (EQ Result (fail)) (fail) Result)))

(DEFUN shen.<clauses*> (V940)
 (LET
  ((Result
    (LET ((Parse_shen.<clause*> (shen.<clause*> V940)))
     (IF (NOT (EQ (fail) Parse_shen.<clause*>))
      (LET ((Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>)))
       (IF (NOT (EQ (fail) Parse_shen.<clauses*>))
        (shen.pair (CAR Parse_shen.<clauses*>)
         (CONS (shen.hdtl Parse_shen.<clause*>)
          (shen.hdtl Parse_shen.<clauses*>)))
        (fail)))
      (fail)))))
  (IF (EQ Result (fail))
   (LET
    ((Result
      (LET ((Parse_<e> (<e> V940)))
       (IF (NOT (EQ (fail) Parse_<e>))
        (shen.pair (CAR Parse_<e>) (APPEND (shen.hdtl Parse_<e>) NIL))
        (fail)))))
    (IF (EQ Result (fail)) (fail) Result))
   Result)))

(DEFUN shen.<clause*> (V945)
 (LET
  ((Result
    (LET ((Parse_shen.<head*> (shen.<head*> V945)))
     (IF (NOT (EQ (fail) Parse_shen.<head*>))
      (IF
       (AND (CONSP (CAR Parse_shen.<head*>))
        (EQ '<-- (CAR (CAR Parse_shen.<head*>))))
       (LET
        ((Parse_shen.<body*>
          (shen.<body*>
           (shen.pair (CDR (CAR Parse_shen.<head*>))
            (shen.hdtl Parse_shen.<head*>)))))
        (IF (NOT (EQ (fail) Parse_shen.<body*>))
         (LET ((Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>)))
          (IF (NOT (EQ (fail) Parse_shen.<end*>))
           (shen.pair (CAR Parse_shen.<end*>)
            (CONS (shen.hdtl Parse_shen.<head*>)
             (CONS (shen.hdtl Parse_shen.<body*>) NIL)))
           (fail)))
         (fail)))
       (fail))
      (fail)))))
  (IF (EQ Result (fail)) (fail) Result)))

(DEFUN shen.<head*> (V950)
 (LET
  ((Result
    (LET ((Parse_shen.<term*> (shen.<term*> V950)))
     (IF (NOT (EQ (fail) Parse_shen.<term*>))
      (LET ((Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>)))
       (IF (NOT (EQ (fail) Parse_shen.<head*>))
        (shen.pair (CAR Parse_shen.<head*>)
         (CONS (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>)))
        (fail)))
      (fail)))))
  (IF (EQ Result (fail))
   (LET
    ((Result
      (LET ((Parse_<e> (<e> V950)))
       (IF (NOT (EQ (fail) Parse_<e>))
        (shen.pair (CAR Parse_<e>) (APPEND (shen.hdtl Parse_<e>) NIL))
        (fail)))))
    (IF (EQ Result (fail)) (fail) Result))
   Result)))

(DEFUN shen.<term*> (V955)
 (LET
  ((Result
    (IF (CONSP (CAR V955))
     (LET ((Parse_X (CAR (CAR V955))))
      (IF
       (AND (NOT (EQ '<-- Parse_X))
        (shen.wrapper (shen.legitimate-term? Parse_X)))
       (shen.pair (CAR (shen.pair (CDR (CAR V955)) (shen.hdtl V955)))
        (shen.eval-cons Parse_X))
       (fail)))
     (fail))))
  (IF (EQ Result (fail)) (fail) Result)))

(DEFUN shen.legitimate-term? (V960)
 (COND
  ((AND (CONSP V960)
    (AND (EQ 'cons (CAR V960))
     (AND (CONSP (CDR V960))
      (AND (CONSP (CDR (CDR V960))) (NULL (CDR (CDR (CDR V960))))))))
   (and (shen.legitimate-term? (CAR (CDR V960)))
    (shen.legitimate-term? (CAR (CDR (CDR V960))))))
  ((AND (CONSP V960)
    (AND (EQ 'mode (CAR V960))
     (AND (CONSP (CDR V960))
      (AND (CONSP (CDR (CDR V960)))
       (AND (EQ '+ (CAR (CDR (CDR V960)))) (NULL (CDR (CDR (CDR V960)))))))))
   (shen.legitimate-term? (CAR (CDR V960))))
  ((AND (CONSP V960)
    (AND (EQ 'mode (CAR V960))
     (AND (CONSP (CDR V960))
      (AND (CONSP (CDR (CDR V960)))
       (AND (EQ '- (CAR (CDR (CDR V960)))) (NULL (CDR (CDR (CDR V960)))))))))
   (shen.legitimate-term? (CAR (CDR V960))))
  ((CONSP V960) 'false) (T 'true)))

(DEFUN shen.eval-cons (V961)
 (COND
  ((AND (CONSP V961)
    (AND (EQ 'cons (CAR V961))
     (AND (CONSP (CDR V961))
      (AND (CONSP (CDR (CDR V961))) (NULL (CDR (CDR (CDR V961))))))))
   (CONS (shen.eval-cons (CAR (CDR V961)))
    (shen.eval-cons (CAR (CDR (CDR V961))))))
  ((AND (CONSP V961)
    (AND (EQ 'mode (CAR V961))
     (AND (CONSP (CDR V961))
      (AND (CONSP (CDR (CDR V961))) (NULL (CDR (CDR (CDR V961))))))))
   (CONS 'mode (CONS (shen.eval-cons (CAR (CDR V961))) (CDR (CDR V961)))))
  (T V961)))

(DEFUN shen.<body*> (V966)
 (LET
  ((Result
    (LET ((Parse_shen.<literal*> (shen.<literal*> V966)))
     (IF (NOT (EQ (fail) Parse_shen.<literal*>))
      (LET ((Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>)))
       (IF (NOT (EQ (fail) Parse_shen.<body*>))
        (shen.pair (CAR Parse_shen.<body*>)
         (CONS (shen.hdtl Parse_shen.<literal*>)
          (shen.hdtl Parse_shen.<body*>)))
        (fail)))
      (fail)))))
  (IF (EQ Result (fail))
   (LET
    ((Result
      (LET ((Parse_<e> (<e> V966)))
       (IF (NOT (EQ (fail) Parse_<e>))
        (shen.pair (CAR Parse_<e>) (APPEND (shen.hdtl Parse_<e>) NIL))
        (fail)))))
    (IF (EQ Result (fail)) (fail) Result))
   Result)))

(DEFUN shen.<literal*> (V971)
 (LET
  ((Result
    (IF (AND (CONSP (CAR V971)) (EQ '! (CAR (CAR V971))))
     (shen.pair (CAR (shen.pair (CDR (CAR V971)) (shen.hdtl V971)))
      (CONS 'cut (CONS (intern "Throwcontrol") NIL)))
     (fail))))
  (IF (EQ Result (fail))
   (LET
    ((Result
      (IF (CONSP (CAR V971))
       (LET ((Parse_X (CAR (CAR V971))))
        (IF (CONSP Parse_X)
         (shen.pair (CAR (shen.pair (CDR (CAR V971)) (shen.hdtl V971)))
          Parse_X)
         (fail)))
       (fail))))
    (IF (EQ Result (fail)) (fail) Result))
   Result)))

(DEFUN shen.<end*> (V976)
 (LET
  ((Result
    (IF (CONSP (CAR V976))
     (LET ((Parse_X (CAR (CAR V976))))
      (IF (shen.ABSEQUAL Parse_X '|;|)
       (shen.pair (CAR (shen.pair (CDR (CAR V976)) (shen.hdtl V976))) Parse_X)
       (fail)))
     (fail))))
  (IF (EQ Result (fail)) (fail) Result)))

(DEFUN cut (V977 V978 V979)
 (LET ((Result (thaw V979))) (IF (shen.ABSEQUAL Result 'false) V977 Result)))

(DEFUN shen.insert_modes (V980)
 (COND
  ((AND (CONSP V980)
    (AND (EQ 'mode (CAR V980))
     (AND (CONSP (CDR V980))
      (AND (CONSP (CDR (CDR V980))) (NULL (CDR (CDR (CDR V980))))))))
   V980)
  ((NULL V980) NIL)
  ((CONSP V980)
   (CONS (CONS 'mode (CONS (CAR V980) (CONS '+ NIL)))
    (CONS 'mode (CONS (shen.insert_modes (CDR V980)) (CONS '- NIL)))))
  (T V980)))

(DEFUN shen.s-prolog (V981)
 (map #'(LAMBDA (V907) (eval V907)) (shen.prolog->shen V981)))

(DEFUN shen.prolog->shen (V982)
 (map 'shen.compile_prolog_procedure
  (shen.group_clauses
   (map 'shen.s-prolog_clause (mapcan 'shen.head_abstraction V982)))))

(DEFUN shen.s-prolog_clause (V983)
 (COND
  ((AND (CONSP V983)
    (AND (CONSP (CDR V983))
     (AND (EQ '|:-| (CAR (CDR V983)))
      (AND (CONSP (CDR (CDR V983))) (NULL (CDR (CDR (CDR V983))))))))
   (CONS (CAR V983)
    (CONS '|:-|
     (CONS (map 'shen.s-prolog_literal (CAR (CDR (CDR V983)))) NIL))))
  (T (shen.sys-error 'shen.s-prolog_clause))))

(DEFUN shen.head_abstraction (V984)
 (COND
  ((AND (CONSP V984)
    (AND (CONSP (CDR V984))
     (AND (EQ '|:-| (CAR (CDR V984)))
      (AND (CONSP (CDR (CDR V984)))
       (AND (NULL (CDR (CDR (CDR V984))))
        (< (shen.complexity_head (CAR V984)) shen.*maxcomplexity*))))))
   (CONS V984 NIL))
  ((AND (CONSP V984)
    (AND (CONSP (CAR V984))
     (AND (CONSP (CDR V984))
      (AND (EQ '|:-| (CAR (CDR V984)))
       (AND (CONSP (CDR (CDR V984))) (NULL (CDR (CDR (CDR V984)))))))))
   (LET ((Terms (map #'(LAMBDA (Y) (gensym 'V)) (CDR (CAR V984)))))
    (LET ((XTerms (shen.rcons_form (shen.remove_modes (CDR (CAR V984))))))
     (LET
      ((Literal (CONS 'unify (CONS (shen.cons_form Terms) (CONS XTerms NIL)))))
      (LET
       ((Clause
         (CONS (CONS (CAR (CAR V984)) Terms)
          (CONS '|:-| (CONS (CONS Literal (CAR (CDR (CDR V984)))) NIL)))))
       (CONS Clause NIL))))))
  (T (shen.sys-error 'shen.head_abstraction))))

(DEFUN shen.complexity_head (V989)
 (COND ((CONSP V989) (shen.product (map 'shen.complexity (CDR V989))))
  (T (shen.sys-error 'shen.complexity_head))))

(DEFUN shen.complexity (V997)
 (COND
  ((AND (CONSP V997)
    (AND (EQ 'mode (CAR V997))
     (AND (CONSP (CDR V997))
      (AND (CONSP (CAR (CDR V997)))
       (AND (EQ 'mode (CAR (CAR (CDR V997))))
        (AND (CONSP (CDR (CAR (CDR V997))))
         (AND (CONSP (CDR (CDR (CAR (CDR V997)))))
          (AND (NULL (CDR (CDR (CDR (CAR (CDR V997))))))
           (AND (CONSP (CDR (CDR V997))) (NULL (CDR (CDR (CDR V997)))))))))))))
   (shen.complexity (CAR (CDR V997))))
  ((AND (CONSP V997)
    (AND (EQ 'mode (CAR V997))
     (AND (CONSP (CDR V997))
      (AND (CONSP (CAR (CDR V997)))
       (AND (CONSP (CDR (CDR V997)))
        (AND (EQ '+ (CAR (CDR (CDR V997)))) (NULL (CDR (CDR (CDR V997))))))))))
   (shen.multiply 2
    (shen.multiply
     (shen.complexity
      (CONS 'mode (CONS (CAR (CAR (CDR V997))) (CDR (CDR V997)))))
     (shen.complexity
      (CONS 'mode (CONS (CDR (CAR (CDR V997))) (CDR (CDR V997))))))))
  ((AND (CONSP V997)
    (AND (EQ 'mode (CAR V997))
     (AND (CONSP (CDR V997))
      (AND (CONSP (CAR (CDR V997)))
       (AND (CONSP (CDR (CDR V997)))
        (AND (EQ '- (CAR (CDR (CDR V997)))) (NULL (CDR (CDR (CDR V997))))))))))
   (shen.multiply
    (shen.complexity
     (CONS 'mode (CONS (CAR (CAR (CDR V997))) (CDR (CDR V997)))))
    (shen.complexity
     (CONS 'mode (CONS (CDR (CAR (CDR V997))) (CDR (CDR V997)))))))
  ((AND (CONSP V997)
    (AND (EQ 'mode (CAR V997))
     (AND (CONSP (CDR V997))
      (AND (CONSP (CDR (CDR V997)))
       (AND (NULL (CDR (CDR (CDR V997))))
        (shen.wrapper (variable? (CAR (CDR V997)))))))))
   1)
  ((AND (CONSP V997)
    (AND (EQ 'mode (CAR V997))
     (AND (CONSP (CDR V997))
      (AND (CONSP (CDR (CDR V997)))
       (AND (EQ '+ (CAR (CDR (CDR V997)))) (NULL (CDR (CDR (CDR V997)))))))))
   2)
  ((AND (CONSP V997)
    (AND (EQ 'mode (CAR V997))
     (AND (CONSP (CDR V997))
      (AND (CONSP (CDR (CDR V997)))
       (AND (EQ '- (CAR (CDR (CDR V997)))) (NULL (CDR (CDR (CDR V997)))))))))
   1)
  (T (shen.complexity (CONS 'mode (CONS V997 (CONS '+ NIL)))))))

(DEFUN shen.product (V998)
 (COND ((NULL V998) 1)
  ((CONSP V998) (shen.multiply (CAR V998) (shen.product (CDR V998))))
  (T (shen.sys-error 'shen.product))))

(DEFUN shen.s-prolog_literal (V999)
 (COND
  ((AND (CONSP V999)
    (AND (EQ 'is (CAR V999))
     (AND (CONSP (CDR V999))
      (AND (CONSP (CDR (CDR V999))) (NULL (CDR (CDR (CDR V999))))))))
   (CONS 'bind
    (CONS (CAR (CDR V999))
     (CONS (shen.insert_deref (CAR (CDR (CDR V999)))) NIL))))
  ((AND (CONSP V999)
    (AND (EQ 'when (CAR V999))
     (AND (CONSP (CDR V999)) (NULL (CDR (CDR V999))))))
   (CONS 'fwhen (CONS (shen.insert_deref (CAR (CDR V999))) NIL)))
  ((AND (CONSP V999)
    (AND (EQ 'bind (CAR V999))
     (AND (CONSP (CDR V999))
      (AND (CONSP (CDR (CDR V999))) (NULL (CDR (CDR (CDR V999))))))))
   (CONS 'bind
    (CONS (CAR (CDR V999))
     (CONS (shen.insert_lazyderef (CAR (CDR (CDR V999)))) NIL))))
  ((AND (CONSP V999)
    (AND (EQ 'fwhen (CAR V999))
     (AND (CONSP (CDR V999)) (NULL (CDR (CDR V999))))))
   (CONS 'fwhen (CONS (shen.insert_lazyderef (CAR (CDR V999))) NIL)))
  ((CONSP V999)
   (CONS (shen.m_prolog_to_s-prolog_predicate (CAR V999)) (CDR V999)))
  (T (shen.sys-error 'shen.s-prolog_literal))))

(DEFUN shen.insert_deref (V1000)
 (COND
  ((shen.wrapper (variable? V1000))
   (CONS 'shen.deref (CONS V1000 (CONS 'ProcessN NIL))))
  ((CONSP V1000)
   (CONS (shen.insert_deref (CAR V1000)) (shen.insert_deref (CDR V1000))))
  (T V1000)))

(DEFUN shen.insert_lazyderef (V1001)
 (COND
  ((shen.wrapper (variable? V1001))
   (CONS 'shen.lazyderef (CONS V1001 (CONS 'ProcessN NIL))))
  ((CONSP V1001)
   (CONS (shen.insert_lazyderef (CAR V1001))
    (shen.insert_lazyderef (CDR V1001))))
  (T V1001)))

(DEFUN shen.m_prolog_to_s-prolog_predicate (V1002)
 (COND ((EQ '= V1002) 'unify) ((EQ '=! V1002) 'unify!)
  ((EQ '== V1002) 'identical) (T V1002)))

(DEFUN shen.group_clauses (V1003)
 (COND ((NULL V1003) NIL)
  ((CONSP V1003)
   (LET
    ((Group
      (shen.collect #'(LAMBDA (X) (shen.same_predicate? (CAR V1003) X))
       V1003)))
    (LET ((Rest (difference V1003 Group)))
     (CONS Group (shen.group_clauses Rest)))))
  (T (shen.sys-error 'shen.group_clauses))))

(DEFUN shen.collect (V1006 V1007)
 (COND ((NULL V1007) NIL)
  ((CONSP V1007)
   (IF
    (shen.wrapper
     (let Args (LIST (CAR V1007))
      (let NewF (shen.maplispsym V1006)
       (trap-error (APPLY NewF Args)
        (lambda E
         (COND
          ((shen.arity-error? V1006 Args)
           (shen.funcall (EVAL (shen.nest-lambda V1006 NewF)) Args))
          ((EQ NewF 'or)
           (shen.funcall (lambda X1 (lambda X2 (or X1 X2))) Args))
          ((EQ NewF 'and)
           (shen.funcall (lambda X1 (lambda X2 (and X1 X2))) Args))
          ((EQ NewF 'trap-error)
           (shen.funcall (lambda X1 (lambda X2 (trap-error X1 X2))) Args))
          ((shen.bad-lambda-call? NewF Args) (shen.funcall NewF Args))
          (T (shen.relay-error E))))))))
    (CONS (CAR V1007) (shen.collect V1006 (CDR V1007)))
    (shen.collect V1006 (CDR V1007))))
  (T (shen.sys-error 'shen.collect))))

(DEFUN shen.same_predicate? (V1024 V1025)
 (COND
  ((AND (CONSP V1024)
    (AND (CONSP (CAR V1024)) (AND (CONSP V1025) (CONSP (CAR V1025)))))
   (shen.equal? (CAR (CAR V1024)) (CAR (CAR V1025))))
  (T (shen.sys-error 'shen.same_predicate?))))

(DEFUN shen.compile_prolog_procedure (V1026)
 (LET ((F (shen.procedure_name V1026)))
  (LET ((Shen (shen.clauses-to-shen F V1026))) Shen)))

(DEFUN shen.procedure_name (V1039)
 (COND
  ((AND (CONSP V1039) (AND (CONSP (CAR V1039)) (CONSP (CAR (CAR V1039)))))
   (CAR (CAR (CAR V1039))))
  (T (shen.sys-error 'shen.procedure_name))))

(DEFUN shen.clauses-to-shen (V1040 V1041)
 (LET ((Linear (map 'shen.linearise-clause V1041)))
  (LET
   ((Arity
     (shen.prolog-aritycheck V1040 (map #'(LAMBDA (V908) (head V908)) V1041))))
   (LET ((Parameters (shen.parameters Arity)))
    (LET
     ((AUM_instructions (map #'(LAMBDA (X) (shen.aum X Parameters)) Linear)))
     (LET
      ((Code
        (shen.catch-cut
         (shen.nest-disjunct (map 'shen.aum_to_shen AUM_instructions)))))
      (LET
       ((ShenDef
         (CONS 'define
          (CONS V1040
           (APPEND Parameters
            (APPEND (CONS 'ProcessN (CONS 'Continuation NIL))
             (CONS '-> (CONS Code NIL))))))))
       ShenDef)))))))

(DEFUN shen.catch-cut (V1042)
 (COND ((NOT (shen.wrapper (shen.occurs? 'cut V1042))) V1042)
  (T
   (CONS 'let
    (CONS 'Throwcontrol
     (CONS (CONS 'shen.catchpoint NIL)
      (CONS (CONS 'shen.cutpoint (CONS 'Throwcontrol (CONS V1042 NIL)))
       NIL)))))))

(DEFUN shen.catchpoint NIL (INCF shen.*catch*))

(DEFUN shen.cutpoint (V1047 V1048)
 (COND ((shen.ABSEQUAL V1048 V1047) 'false) (T V1048)))

(DEFUN shen.nest-disjunct (V1050)
 (COND ((AND (CONSP V1050) (NULL (CDR V1050))) (CAR V1050))
  ((CONSP V1050) (shen.lisp-or (CAR V1050) (shen.nest-disjunct (CDR V1050))))
  (T (shen.sys-error 'shen.nest-disjunct))))

(DEFUN shen.lisp-or (V1051 V1052)
 (CONS 'let
  (CONS 'Case
   (CONS V1051
    (CONS
     (CONS 'if
      (CONS (CONS '= (CONS 'Case (CONS 'false NIL)))
       (CONS V1052 (CONS 'Case NIL))))
     NIL)))))

(DEFUN shen.prolog-aritycheck (V1055 V1056)
 (COND ((AND (CONSP V1056) (NULL (CDR V1056))) (1- (length (CAR V1056))))
  ((AND (CONSP V1056) (CONSP (CDR V1056)))
   (IF (shen.ABSEQUAL (length (CAR V1056)) (length (CAR (CDR V1056))))
    (shen.prolog-aritycheck V1055 (CDR V1056))
    (simple-error
     (cn "arity error in prolog procedure "
      (shen.app (CONS V1055 NIL)
       "
"
       'shen.a)))))
  (T (shen.sys-error 'shen.prolog-aritycheck))))

(DEFUN shen.linearise-clause (V1057)
 (COND
  ((AND (CONSP V1057)
    (AND (CONSP (CDR V1057))
     (AND (EQ '|:-| (CAR (CDR V1057)))
      (AND (CONSP (CDR (CDR V1057))) (NULL (CDR (CDR (CDR V1057))))))))
   (LET ((Linear (shen.linearise (CONS (CAR V1057) (CDR (CDR V1057))))))
    (shen.clause_form Linear)))
  (T (shen.sys-error 'shen.linearise-clause))))

(DEFUN shen.clause_form (V1058)
 (COND
  ((AND (CONSP V1058) (AND (CONSP (CDR V1058)) (NULL (CDR (CDR V1058)))))
   (CONS (shen.explicit_modes (CAR V1058))
    (CONS '|:-| (CONS (shen.cf_help (CAR (CDR V1058))) NIL))))
  (T (shen.sys-error 'shen.clause_form))))

(DEFUN shen.explicit_modes (V1059)
 (COND ((CONSP V1059) (CONS (CAR V1059) (map 'shen.em_help (CDR V1059))))
  (T (shen.sys-error 'shen.explicit_modes))))

(DEFUN shen.em_help (V1060)
 (COND
  ((AND (CONSP V1060)
    (AND (EQ 'mode (CAR V1060))
     (AND (CONSP (CDR V1060))
      (AND (CONSP (CDR (CDR V1060))) (NULL (CDR (CDR (CDR V1060))))))))
   V1060)
  (T (CONS 'mode (CONS V1060 (CONS '+ NIL))))))

(DEFUN shen.cf_help (V1061)
 (COND
  ((AND (CONSP V1061)
    (AND (EQ 'where (CAR V1061))
     (AND (CONSP (CDR V1061))
      (AND (CONSP (CAR (CDR V1061)))
       (AND (EQ '= (CAR (CAR (CDR V1061))))
        (AND (CONSP (CDR (CAR (CDR V1061))))
         (AND (CONSP (CDR (CDR (CAR (CDR V1061)))))
          (AND (NULL (CDR (CDR (CDR (CAR (CDR V1061))))))
           (AND (CONSP (CDR (CDR V1061)))
            (NULL (CDR (CDR (CDR V1061)))))))))))))
   (CONS
    (CONS (IF (shen.wrapper shen.*occurs*) 'unify! 'unify)
     (CDR (CAR (CDR V1061))))
    (shen.cf_help (CAR (CDR (CDR V1061))))))
  (T V1061)))

(DEFUN occurs-check (V1066)
 (COND ((EQ '+ V1066) (set 'shen.*occurs* 'true))
  ((EQ '- V1066) (set 'shen.*occurs* 'false))
  (T
   (simple-error
    "occurs-check expects + or -
"))))

(DEFUN shen.aum (V1067 V1068)
 (COND
  ((AND (CONSP V1067)
    (AND (CONSP (CAR V1067))
     (AND (CONSP (CDR V1067))
      (AND (EQ '|:-| (CAR (CDR V1067)))
       (AND (CONSP (CDR (CDR V1067))) (NULL (CDR (CDR (CDR V1067)))))))))
   (LET
    ((MuApplication
      (shen.make_mu_application
       (CONS 'shen.mu
        (CONS (CDR (CAR V1067))
         (CONS
          (shen.continuation_call (CDR (CAR V1067)) (CAR (CDR (CDR V1067))))
          NIL)))
       V1068)))
    (shen.mu_reduction MuApplication '+)))
  (T (shen.sys-error 'shen.aum))))

(DEFUN shen.continuation_call (V1069 V1070)
 (LET ((VTerms (CONS 'ProcessN (shen.extract_vars V1069))))
  (LET ((VBody (shen.extract_vars V1070)))
   (LET ((Free (remove 'Throwcontrol (difference VBody VTerms))))
    (shen.cc_help Free V1070)))))

(DEFUN remove (V1071 V1072) (shen.remove-h V1071 V1072 NIL))

(DEFUN shen.remove-h (V1075 V1076 V1077)
 (COND ((NULL V1076) (REVERSE V1077))
  ((AND (CONSP V1076) (shen.ABSEQUAL (CAR V1076) V1075))
   (shen.remove-h (CAR V1076) (CDR V1076) V1077))
  ((CONSP V1076) (shen.remove-h V1075 (CDR V1076) (CONS (CAR V1076) V1077)))
  (T (shen.sys-error 'shen.remove-h))))

(DEFUN shen.cc_help (V1079 V1080)
 (COND
  ((AND (NULL V1079) (NULL V1080))
   (CONS 'shen.pop (CONS 'shen.the (CONS 'shen.stack NIL))))
  ((NULL V1080)
   (CONS 'shen.rename
    (CONS 'shen.the
     (CONS 'shen.variables
      (CONS 'in
       (CONS V1079
        (CONS 'and
         (CONS 'shen.then
          (CONS (CONS 'shen.pop (CONS 'shen.the (CONS 'shen.stack NIL)))
           NIL)))))))))
  ((NULL V1079)
   (CONS 'call (CONS 'shen.the (CONS 'shen.continuation (CONS V1080 NIL)))))
  (T
   (CONS 'shen.rename
    (CONS 'shen.the
     (CONS 'shen.variables
      (CONS 'in
       (CONS V1079
        (CONS 'and
         (CONS 'shen.then
          (CONS
           (CONS 'call
            (CONS 'shen.the (CONS 'shen.continuation (CONS V1080 NIL))))
           NIL)))))))))))

(DEFUN shen.make_mu_application (V1081 V1082)
 (COND
  ((AND (CONSP V1081)
    (AND (EQ 'shen.mu (CAR V1081))
     (AND (CONSP (CDR V1081))
      (AND (NULL (CAR (CDR V1081)))
       (AND (CONSP (CDR (CDR V1081)))
        (AND (NULL (CDR (CDR (CDR V1081)))) (NULL V1082)))))))
   (CAR (CDR (CDR V1081))))
  ((AND (CONSP V1081)
    (AND (EQ 'shen.mu (CAR V1081))
     (AND (CONSP (CDR V1081))
      (AND (CONSP (CAR (CDR V1081)))
       (AND (CONSP (CDR (CDR V1081)))
        (AND (NULL (CDR (CDR (CDR V1081)))) (CONSP V1082)))))))
   (CONS
    (CONS 'shen.mu
     (CONS (CAR (CAR (CDR V1081)))
      (CONS
       (shen.make_mu_application
        (CONS 'shen.mu (CONS (CDR (CAR (CDR V1081))) (CDR (CDR V1081))))
        (CDR V1082))
       NIL)))
    (CONS (CAR V1082) NIL)))
  (T (shen.sys-error 'shen.make_mu_application))))

(DEFUN shen.mu_reduction (V1089 V1090)
 (COND
  ((AND (CONSP V1089)
    (AND (CONSP (CAR V1089))
     (AND (EQ 'shen.mu (CAR (CAR V1089)))
      (AND (CONSP (CDR (CAR V1089)))
       (AND (CONSP (CAR (CDR (CAR V1089))))
        (AND (EQ 'mode (CAR (CAR (CDR (CAR V1089)))))
         (AND (CONSP (CDR (CAR (CDR (CAR V1089)))))
          (AND (CONSP (CDR (CDR (CAR (CDR (CAR V1089))))))
           (AND (NULL (CDR (CDR (CDR (CAR (CDR (CAR V1089)))))))
            (AND (CONSP (CDR (CDR (CAR V1089))))
             (AND (NULL (CDR (CDR (CDR (CAR V1089)))))
              (AND (CONSP (CDR V1089)) (NULL (CDR (CDR V1089)))))))))))))))
   (shen.mu_reduction
    (CONS
     (CONS 'shen.mu
      (CONS (CAR (CDR (CAR (CDR (CAR V1089))))) (CDR (CDR (CAR V1089)))))
     (CDR V1089))
    (CAR (CDR (CDR (CAR (CDR (CAR V1089))))))))
  ((AND (CONSP V1089)
    (AND (CONSP (CAR V1089))
     (AND (EQ 'shen.mu (CAR (CAR V1089)))
      (AND (CONSP (CDR (CAR V1089)))
       (AND (CONSP (CDR (CDR (CAR V1089))))
        (AND (NULL (CDR (CDR (CDR (CAR V1089)))))
         (AND (CONSP (CDR V1089))
          (AND (NULL (CDR (CDR V1089))) (EQ '_ (CAR (CDR (CAR V1089))))))))))))
   (shen.mu_reduction (CAR (CDR (CDR (CAR V1089)))) V1090))
  ((AND (CONSP V1089)
    (AND (CONSP (CAR V1089))
     (AND (EQ 'shen.mu (CAR (CAR V1089)))
      (AND (CONSP (CDR (CAR V1089)))
       (AND (CONSP (CDR (CDR (CAR V1089))))
        (AND (NULL (CDR (CDR (CDR (CAR V1089)))))
         (AND (CONSP (CDR V1089))
          (AND (NULL (CDR (CDR V1089)))
           (shen.wrapper
            (shen.ephemeral_variable? (CAR (CDR (CAR V1089)))
             (CAR (CDR V1089))))))))))))
   (subst (CAR (CDR V1089)) (CAR (CDR (CAR V1089)))
    (shen.mu_reduction (CAR (CDR (CDR (CAR V1089)))) V1090)))
  ((AND (CONSP V1089)
    (AND (CONSP (CAR V1089))
     (AND (EQ 'shen.mu (CAR (CAR V1089)))
      (AND (CONSP (CDR (CAR V1089)))
       (AND (CONSP (CDR (CDR (CAR V1089))))
        (AND (NULL (CDR (CDR (CDR (CAR V1089)))))
         (AND (CONSP (CDR V1089))
          (AND (NULL (CDR (CDR V1089)))
           (shen.wrapper (variable? (CAR (CDR (CAR V1089)))))))))))))
   (CONS 'let
    (CONS (CAR (CDR (CAR V1089)))
     (CONS 'shen.be
      (CONS (CAR (CDR V1089))
       (CONS 'in
        (CONS (shen.mu_reduction (CAR (CDR (CDR (CAR V1089)))) V1090)
         NIL)))))))
  ((AND (CONSP V1089)
    (AND (CONSP (CAR V1089))
     (AND (EQ 'shen.mu (CAR (CAR V1089)))
      (AND (CONSP (CDR (CAR V1089)))
       (AND (CONSP (CDR (CDR (CAR V1089))))
        (AND (NULL (CDR (CDR (CDR (CAR V1089)))))
         (AND (CONSP (CDR V1089))
          (AND (NULL (CDR (CDR V1089)))
           (AND (EQ '- V1090)
            (shen.wrapper
             (shen.prolog_constant? (CAR (CDR (CAR V1089))))))))))))))
   (LET ((Z (gensym 'V)))
    (CONS 'let
     (CONS Z
      (CONS 'shen.be
       (CONS
        (CONS 'shen.the
         (CONS 'shen.result
          (CONS 'shen.of (CONS 'shen.dereferencing (CDR V1089)))))
        (CONS 'in
         (CONS
          (CONS 'if
           (CONS
            (CONS Z
             (CONS 'is
              (CONS 'identical
               (CONS 'shen.to (CONS (CAR (CDR (CAR V1089))) NIL)))))
            (CONS 'shen.then
             (CONS (shen.mu_reduction (CAR (CDR (CDR (CAR V1089)))) '-)
              (CONS 'shen.else (CONS 'shen.failed! NIL))))))
          NIL))))))))
  ((AND (CONSP V1089)
    (AND (CONSP (CAR V1089))
     (AND (EQ 'shen.mu (CAR (CAR V1089)))
      (AND (CONSP (CDR (CAR V1089)))
       (AND (CONSP (CDR (CDR (CAR V1089))))
        (AND (NULL (CDR (CDR (CDR (CAR V1089)))))
         (AND (CONSP (CDR V1089))
          (AND (NULL (CDR (CDR V1089)))
           (AND (EQ '+ V1090)
            (shen.wrapper
             (shen.prolog_constant? (CAR (CDR (CAR V1089))))))))))))))
   (LET ((Z (gensym 'V)))
    (CONS 'let
     (CONS Z
      (CONS 'shen.be
       (CONS
        (CONS 'shen.the
         (CONS 'shen.result
          (CONS 'shen.of (CONS 'shen.dereferencing (CDR V1089)))))
        (CONS 'in
         (CONS
          (CONS 'if
           (CONS
            (CONS Z
             (CONS 'is
              (CONS 'identical
               (CONS 'shen.to (CONS (CAR (CDR (CAR V1089))) NIL)))))
            (CONS 'shen.then
             (CONS (shen.mu_reduction (CAR (CDR (CDR (CAR V1089)))) '+)
              (CONS 'shen.else
               (CONS
                (CONS 'if
                 (CONS
                  (CONS Z (CONS 'is (CONS 'shen.a (CONS 'shen.variable NIL))))
                  (CONS 'shen.then
                   (CONS
                    (CONS 'bind
                     (CONS Z
                      (CONS 'shen.to
                       (CONS (CAR (CDR (CAR V1089)))
                        (CONS 'in
                         (CONS
                          (shen.mu_reduction (CAR (CDR (CDR (CAR V1089)))) '+)
                          NIL))))))
                    (CONS 'shen.else (CONS 'shen.failed! NIL))))))
                NIL))))))
          NIL))))))))
  ((AND (CONSP V1089)
    (AND (CONSP (CAR V1089))
     (AND (EQ 'shen.mu (CAR (CAR V1089)))
      (AND (CONSP (CDR (CAR V1089)))
       (AND (CONSP (CAR (CDR (CAR V1089))))
        (AND (CONSP (CDR (CDR (CAR V1089))))
         (AND (NULL (CDR (CDR (CDR (CAR V1089)))))
          (AND (CONSP (CDR V1089))
           (AND (NULL (CDR (CDR V1089))) (EQ '- V1090))))))))))
   (LET ((Z (gensym 'V)))
    (CONS 'let
     (CONS Z
      (CONS 'shen.be
       (CONS
        (CONS 'shen.the
         (CONS 'shen.result
          (CONS 'shen.of (CONS 'shen.dereferencing (CDR V1089)))))
        (CONS 'in
         (CONS
          (CONS 'if
           (CONS
            (CONS Z
             (CONS 'is (CONS 'shen.a (CONS 'shen.non-empty (CONS 'list NIL)))))
            (CONS 'shen.then
             (CONS
              (shen.mu_reduction
               (CONS
                (CONS 'shen.mu
                 (CONS (CAR (CAR (CDR (CAR V1089))))
                  (CONS
                   (CONS
                    (CONS 'shen.mu
                     (CONS (CDR (CAR (CDR (CAR V1089))))
                      (CDR (CDR (CAR V1089)))))
                    (CONS
                     (CONS 'shen.the (CONS 'tail (CONS 'shen.of (CONS Z NIL))))
                     NIL))
                   NIL)))
                (CONS
                 (CONS 'shen.the (CONS 'head (CONS 'shen.of (CONS Z NIL))))
                 NIL))
               '-)
              (CONS 'shen.else (CONS 'shen.failed! NIL))))))
          NIL))))))))
  ((AND (CONSP V1089)
    (AND (CONSP (CAR V1089))
     (AND (EQ 'shen.mu (CAR (CAR V1089)))
      (AND (CONSP (CDR (CAR V1089)))
       (AND (CONSP (CAR (CDR (CAR V1089))))
        (AND (CONSP (CDR (CDR (CAR V1089))))
         (AND (NULL (CDR (CDR (CDR (CAR V1089)))))
          (AND (CONSP (CDR V1089))
           (AND (NULL (CDR (CDR V1089))) (EQ '+ V1090))))))))))
   (LET ((Z (gensym 'V)))
    (CONS 'let
     (CONS Z
      (CONS 'shen.be
       (CONS
        (CONS 'shen.the
         (CONS 'shen.result
          (CONS 'shen.of (CONS 'shen.dereferencing (CDR V1089)))))
        (CONS 'in
         (CONS
          (CONS 'if
           (CONS
            (CONS Z
             (CONS 'is (CONS 'shen.a (CONS 'shen.non-empty (CONS 'list NIL)))))
            (CONS 'shen.then
             (CONS
              (shen.mu_reduction
               (CONS
                (CONS 'shen.mu
                 (CONS (CAR (CAR (CDR (CAR V1089))))
                  (CONS
                   (CONS
                    (CONS 'shen.mu
                     (CONS (CDR (CAR (CDR (CAR V1089))))
                      (CDR (CDR (CAR V1089)))))
                    (CONS
                     (CONS 'shen.the (CONS 'tail (CONS 'shen.of (CONS Z NIL))))
                     NIL))
                   NIL)))
                (CONS
                 (CONS 'shen.the (CONS 'head (CONS 'shen.of (CONS Z NIL))))
                 NIL))
               '+)
              (CONS 'shen.else
               (CONS
                (CONS 'if
                 (CONS
                  (CONS Z (CONS 'is (CONS 'shen.a (CONS 'shen.variable NIL))))
                  (CONS 'shen.then
                   (CONS
                    (CONS 'shen.rename
                     (CONS 'shen.the
                      (CONS 'shen.variables
                       (CONS 'in
                        (CONS (shen.extract_vars (CAR (CDR (CAR V1089))))
                         (CONS 'and
                          (CONS 'shen.then
                           (CONS
                            (CONS 'bind
                             (CONS Z
                              (CONS 'shen.to
                               (CONS
                                (shen.rcons_form
                                 (shen.remove_modes (CAR (CDR (CAR V1089)))))
                                (CONS 'in
                                 (CONS
                                  (shen.mu_reduction
                                   (CAR (CDR (CDR (CAR V1089)))) '+)
                                  NIL))))))
                            NIL))))))))
                    (CONS 'shen.else (CONS 'shen.failed! NIL))))))
                NIL))))))
          NIL))))))))
  (T V1089)))

(DEFUN shen.rcons_form (V1091)
 (COND
  ((CONSP V1091)
   (CONS 'cons
    (CONS (shen.rcons_form (CAR V1091))
     (CONS (shen.rcons_form (CDR V1091)) NIL))))
  (T V1091)))

(DEFUN shen.remove_modes (V1092)
 (COND
  ((AND (CONSP V1092)
    (AND (EQ 'mode (CAR V1092))
     (AND (CONSP (CDR V1092))
      (AND (CONSP (CDR (CDR V1092)))
       (AND (EQ '+ (CAR (CDR (CDR V1092)))) (NULL (CDR (CDR (CDR V1092)))))))))
   (shen.remove_modes (CAR (CDR V1092))))
  ((AND (CONSP V1092)
    (AND (EQ 'mode (CAR V1092))
     (AND (CONSP (CDR V1092))
      (AND (CONSP (CDR (CDR V1092)))
       (AND (EQ '- (CAR (CDR (CDR V1092)))) (NULL (CDR (CDR (CDR V1092)))))))))
   (shen.remove_modes (CAR (CDR V1092))))
  ((CONSP V1092)
   (CONS (shen.remove_modes (CAR V1092)) (shen.remove_modes (CDR V1092))))
  (T V1092)))

(DEFUN shen.ephemeral_variable? (V1093 V1094)
 (and (variable? V1093) (variable? V1094)))

(DEFUN shen.prolog_constant? (V1103) (COND ((CONSP V1103) 'false) (T 'true)))

(DEFUN shen.aum_to_shen (V1104)
 (COND
  ((AND (CONSP V1104)
    (AND (EQ 'let (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (CONSP (CDR (CDR V1104)))
       (AND (EQ 'shen.be (CAR (CDR (CDR V1104))))
        (AND (CONSP (CDR (CDR (CDR V1104))))
         (AND (CONSP (CDR (CDR (CDR (CDR V1104)))))
          (AND (EQ 'in (CAR (CDR (CDR (CDR (CDR V1104))))))
           (AND (CONSP (CDR (CDR (CDR (CDR (CDR V1104))))))
            (NULL (CDR (CDR (CDR (CDR (CDR (CDR V1104))))))))))))))))
   (CONS 'let
    (CONS (CAR (CDR V1104))
     (CONS (shen.aum_to_shen (CAR (CDR (CDR (CDR V1104)))))
      (CONS (shen.aum_to_shen (CAR (CDR (CDR (CDR (CDR (CDR V1104)))))))
       NIL)))))
  ((AND (CONSP V1104)
    (AND (EQ 'shen.the (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (EQ 'shen.result (CAR (CDR V1104)))
       (AND (CONSP (CDR (CDR V1104)))
        (AND (EQ 'shen.of (CAR (CDR (CDR V1104))))
         (AND (CONSP (CDR (CDR (CDR V1104))))
          (AND (EQ 'shen.dereferencing (CAR (CDR (CDR (CDR V1104)))))
           (AND (CONSP (CDR (CDR (CDR (CDR V1104)))))
            (NULL (CDR (CDR (CDR (CDR (CDR V1104)))))))))))))))
   (CONS 'shen.lazyderef
    (CONS (shen.aum_to_shen (CAR (CDR (CDR (CDR (CDR V1104))))))
     (CONS 'ProcessN NIL))))
  ((AND (CONSP V1104)
    (AND (EQ 'if (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (CONSP (CDR (CDR V1104)))
       (AND (EQ 'shen.then (CAR (CDR (CDR V1104))))
        (AND (CONSP (CDR (CDR (CDR V1104))))
         (AND (CONSP (CDR (CDR (CDR (CDR V1104)))))
          (AND (EQ 'shen.else (CAR (CDR (CDR (CDR (CDR V1104))))))
           (AND (CONSP (CDR (CDR (CDR (CDR (CDR V1104))))))
            (NULL (CDR (CDR (CDR (CDR (CDR (CDR V1104))))))))))))))))
   (CONS 'if
    (CONS (shen.aum_to_shen (CAR (CDR V1104)))
     (CONS (shen.aum_to_shen (CAR (CDR (CDR (CDR V1104)))))
      (CONS (shen.aum_to_shen (CAR (CDR (CDR (CDR (CDR (CDR V1104)))))))
       NIL)))))
  ((AND (CONSP V1104)
    (AND (CONSP (CDR V1104))
     (AND (EQ 'is (CAR (CDR V1104)))
      (AND (CONSP (CDR (CDR V1104)))
       (AND (EQ 'shen.a (CAR (CDR (CDR V1104))))
        (AND (CONSP (CDR (CDR (CDR V1104))))
         (AND (EQ 'shen.variable (CAR (CDR (CDR (CDR V1104)))))
          (NULL (CDR (CDR (CDR (CDR V1104))))))))))))
   (CONS 'shen.pvar? (CONS (CAR V1104) NIL)))
  ((AND (CONSP V1104)
    (AND (CONSP (CDR V1104))
     (AND (EQ 'is (CAR (CDR V1104)))
      (AND (CONSP (CDR (CDR V1104)))
       (AND (EQ 'shen.a (CAR (CDR (CDR V1104))))
        (AND (CONSP (CDR (CDR (CDR V1104))))
         (AND (EQ 'shen.non-empty (CAR (CDR (CDR (CDR V1104)))))
          (AND (CONSP (CDR (CDR (CDR (CDR V1104)))))
           (AND (EQ 'list (CAR (CDR (CDR (CDR (CDR V1104))))))
            (NULL (CDR (CDR (CDR (CDR (CDR V1104)))))))))))))))
   (CONS 'cons? (CONS (CAR V1104) NIL)))
  ((AND (CONSP V1104)
    (AND (EQ 'shen.rename (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (EQ 'shen.the (CAR (CDR V1104)))
       (AND (CONSP (CDR (CDR V1104)))
        (AND (EQ 'shen.variables (CAR (CDR (CDR V1104))))
         (AND (CONSP (CDR (CDR (CDR V1104))))
          (AND (EQ 'in (CAR (CDR (CDR (CDR V1104)))))
           (AND (CONSP (CDR (CDR (CDR (CDR V1104)))))
            (AND (NULL (CAR (CDR (CDR (CDR (CDR V1104))))))
             (AND (CONSP (CDR (CDR (CDR (CDR (CDR V1104))))))
              (AND (EQ 'and (CAR (CDR (CDR (CDR (CDR (CDR V1104)))))))
               (AND (CONSP (CDR (CDR (CDR (CDR (CDR (CDR V1104)))))))
                (AND
                 (EQ 'shen.then
                  (CAR (CDR (CDR (CDR (CDR (CDR (CDR V1104))))))))
                 (AND (CONSP (CDR (CDR (CDR (CDR (CDR (CDR (CDR V1104))))))))
                  (NULL
                   (CDR
                    (CDR
                     (CDR
                      (CDR (CDR (CDR (CDR (CDR V1104))))))))))))))))))))))))
   (shen.aum_to_shen (CAR (CDR (CDR (CDR (CDR (CDR (CDR (CDR V1104))))))))))
  ((AND (CONSP V1104)
    (AND (EQ 'shen.rename (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (EQ 'shen.the (CAR (CDR V1104)))
       (AND (CONSP (CDR (CDR V1104)))
        (AND (EQ 'shen.variables (CAR (CDR (CDR V1104))))
         (AND (CONSP (CDR (CDR (CDR V1104))))
          (AND (EQ 'in (CAR (CDR (CDR (CDR V1104)))))
           (AND (CONSP (CDR (CDR (CDR (CDR V1104)))))
            (AND (CONSP (CAR (CDR (CDR (CDR (CDR V1104))))))
             (AND (CONSP (CDR (CDR (CDR (CDR (CDR V1104))))))
              (AND (EQ 'and (CAR (CDR (CDR (CDR (CDR (CDR V1104)))))))
               (AND (CONSP (CDR (CDR (CDR (CDR (CDR (CDR V1104)))))))
                (AND
                 (EQ 'shen.then
                  (CAR (CDR (CDR (CDR (CDR (CDR (CDR V1104))))))))
                 (AND (CONSP (CDR (CDR (CDR (CDR (CDR (CDR (CDR V1104))))))))
                  (NULL
                   (CDR
                    (CDR
                     (CDR
                      (CDR (CDR (CDR (CDR (CDR V1104))))))))))))))))))))))))
   (CONS 'let
    (CONS (CAR (CAR (CDR (CDR (CDR (CDR V1104))))))
     (CONS (CONS 'shen.newpv (CONS 'ProcessN NIL))
      (CONS
       (shen.aum_to_shen
        (CONS 'shen.rename
         (CONS 'shen.the
          (CONS 'shen.variables
           (CONS 'in
            (CONS (CDR (CAR (CDR (CDR (CDR (CDR V1104))))))
             (CDR (CDR (CDR (CDR (CDR V1104)))))))))))
       NIL)))))
  ((AND (CONSP V1104)
    (AND (EQ 'bind (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (CONSP (CDR (CDR V1104)))
       (AND (EQ 'shen.to (CAR (CDR (CDR V1104))))
        (AND (CONSP (CDR (CDR (CDR V1104))))
         (AND (CONSP (CDR (CDR (CDR (CDR V1104)))))
          (AND (EQ 'in (CAR (CDR (CDR (CDR (CDR V1104))))))
           (AND (CONSP (CDR (CDR (CDR (CDR (CDR V1104))))))
            (NULL (CDR (CDR (CDR (CDR (CDR (CDR V1104))))))))))))))))
   (CONS 'do
    (CONS
     (CONS 'shen.bindv
      (CONS (CAR (CDR V1104))
       (CONS (shen.chwild (CAR (CDR (CDR (CDR V1104)))))
        (CONS 'ProcessN NIL))))
     (CONS
      (CONS 'let
       (CONS 'Result
        (CONS (shen.aum_to_shen (CAR (CDR (CDR (CDR (CDR (CDR V1104)))))))
         (CONS
          (CONS 'do
           (CONS
            (CONS 'shen.unbindv (CONS (CAR (CDR V1104)) (CONS 'ProcessN NIL)))
            (CONS 'Result NIL)))
          NIL))))
      NIL))))
  ((AND (CONSP V1104)
    (AND (CONSP (CDR V1104))
     (AND (EQ 'is (CAR (CDR V1104)))
      (AND (CONSP (CDR (CDR V1104)))
       (AND (EQ 'identical (CAR (CDR (CDR V1104))))
        (AND (CONSP (CDR (CDR (CDR V1104))))
         (AND (EQ 'shen.to (CAR (CDR (CDR (CDR V1104)))))
          (AND (CONSP (CDR (CDR (CDR (CDR V1104)))))
           (NULL (CDR (CDR (CDR (CDR (CDR V1104))))))))))))))
   (CONS '= (CONS (CAR (CDR (CDR (CDR (CDR V1104))))) (CONS (CAR V1104) NIL))))
  ((EQ 'shen.failed! V1104) 'false)
  ((AND (CONSP V1104)
    (AND (EQ 'shen.the (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (EQ 'head (CAR (CDR V1104)))
       (AND (CONSP (CDR (CDR V1104)))
        (AND (EQ 'shen.of (CAR (CDR (CDR V1104))))
         (AND (CONSP (CDR (CDR (CDR V1104))))
          (NULL (CDR (CDR (CDR (CDR V1104))))))))))))
   (CONS 'hd (CDR (CDR (CDR V1104)))))
  ((AND (CONSP V1104)
    (AND (EQ 'shen.the (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (EQ 'tail (CAR (CDR V1104)))
       (AND (CONSP (CDR (CDR V1104)))
        (AND (EQ 'shen.of (CAR (CDR (CDR V1104))))
         (AND (CONSP (CDR (CDR (CDR V1104))))
          (NULL (CDR (CDR (CDR (CDR V1104))))))))))))
   (CONS 'tl (CDR (CDR (CDR V1104)))))
  ((AND (CONSP V1104)
    (AND (EQ 'shen.pop (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (EQ 'shen.the (CAR (CDR V1104)))
       (AND (CONSP (CDR (CDR V1104)))
        (AND (EQ 'shen.stack (CAR (CDR (CDR V1104))))
         (NULL (CDR (CDR (CDR V1104))))))))))
   (CONS 'do
    (CONS (CONS 'shen.incinfs NIL)
     (CONS (CONS 'thaw (CONS 'Continuation NIL)) NIL))))
  ((AND (CONSP V1104)
    (AND (EQ 'call (CAR V1104))
     (AND (CONSP (CDR V1104))
      (AND (EQ 'shen.the (CAR (CDR V1104)))
       (AND (CONSP (CDR (CDR V1104)))
        (AND (EQ 'shen.continuation (CAR (CDR (CDR V1104))))
         (AND (CONSP (CDR (CDR (CDR V1104))))
          (NULL (CDR (CDR (CDR (CDR V1104))))))))))))
   (CONS 'do
    (CONS (CONS 'shen.incinfs NIL)
     (CONS
      (shen.call_the_continuation (shen.chwild (CAR (CDR (CDR (CDR V1104)))))
       'ProcessN 'Continuation)
      NIL))))
  (T V1104)))

(DEFUN shen.chwild (V1105)
 (COND ((shen.ABSEQUAL V1105 '_) (CONS 'shen.newpv (CONS 'ProcessN NIL)))
  ((CONSP V1105) (map 'shen.chwild V1105)) (T V1105)))

(DEFUN shen.newpv (V1106)
 (LET ((Count+1 (1+ (<-address shen.*varcounter* V1106))))
  (LET ((IncVar (address-> shen.*varcounter* V1106 Count+1)))
   (LET ((Vector (<-address shen.*prologvectors* V1106)))
    (LET
     ((ResizeVectorIfNeeded
       (IF (shen.ABSEQUAL Count+1 (limit Vector))
        (shen.resizeprocessvector V1106 Count+1) 'shen.skip)))
     (shen.mk-pvar Count+1))))))

(DEFUN shen.resizeprocessvector (V1107 V1108)
 (LET ((Vector (<-address shen.*prologvectors* V1107)))
  (LET
   ((BigVector
     (shen.resize-vector Vector (shen.add V1108 V1108) 'shen.-null-)))
   (address-> shen.*prologvectors* V1107 BigVector))))

(DEFUN shen.resize-vector (V1109 V1110 V1111)
 (LET ((BigVector (address-> (absvector (1+ V1110)) 0 V1110)))
  (shen.copy-vector V1109 BigVector (limit V1109) V1110 V1111)))

(DEFUN shen.copy-vector (V1112 V1113 V1114 V1115 V1116)
 (shen.copy-vector-stage-2 (1+ V1114) (1+ V1115) V1116
  (shen.copy-vector-stage-1 1 V1112 V1113 (1+ V1114))))

(DEFUN shen.copy-vector-stage-1 (V1119 V1120 V1121 V1122)
 (COND ((shen.ABSEQUAL V1122 V1119) V1121)
  (T
   (shen.copy-vector-stage-1 (1+ V1119) V1120
    (address-> V1121 V1119 (<-address V1120 V1119)) V1122))))

(DEFUN shen.copy-vector-stage-2 (V1126 V1127 V1128 V1129)
 (COND ((shen.ABSEQUAL V1127 V1126) V1129)
  (T
   (shen.copy-vector-stage-2 (1+ V1126) V1127 V1128
    (address-> V1129 V1126 V1128)))))

(DEFUN shen.mk-pvar (V1131)
 (address-> (address-> (absvector 2) 0 'shen.pvar) 1 V1131))

(DEFUN shen.pvar? (V1132)
 (and (absvector? V1132) (shen.equal? (<-address V1132 0) 'shen.pvar)))

(DEFUN shen.bindv (V1133 V1134 V1135)
 (LET ((Vector (<-address shen.*prologvectors* V1135)))
  (address-> Vector (<-address V1133 1) V1134)))

(DEFUN shen.unbindv (V1136 V1137)
 (LET ((Vector (<-address shen.*prologvectors* V1137)))
  (address-> Vector (<-address V1136 1) 'shen.-null-)))

(DEFUN shen.incinfs NIL (INCF shen.*infs*))

(DEFUN shen.call_the_continuation (V1138 V1139 V1140)
 (COND
  ((AND (CONSP V1138) (AND (CONSP (CAR V1138)) (NULL (CDR V1138))))
   (CONS (CAR (CAR V1138))
    (APPEND (CDR (CAR V1138)) (CONS V1139 (CONS V1140 NIL)))))
  ((AND (CONSP V1138) (CONSP (CAR V1138)))
   (LET ((NewContinuation (shen.newcontinuation (CDR V1138) V1139 V1140)))
    (CONS (CAR (CAR V1138))
     (APPEND (CDR (CAR V1138)) (CONS V1139 (CONS NewContinuation NIL))))))
  (T (shen.sys-error 'shen.call_the_continuation))))

(DEFUN shen.newcontinuation (V1141 V1142 V1143)
 (COND ((NULL V1141) V1143)
  ((AND (CONSP V1141) (CONSP (CAR V1141)))
   (CONS 'freeze
    (CONS
     (CONS (CAR (CAR V1141))
      (APPEND (CDR (CAR V1141))
       (CONS V1142 (CONS (shen.newcontinuation (CDR V1141) V1142 V1143) NIL))))
     NIL)))
  (T (shen.sys-error 'shen.newcontinuation))))

(DEFUN return (V1148 V1149 V1150) (shen.deref V1148 V1149))

(DEFUN shen.measure&return (V1155 V1156 V1157)
 (do
  (shen.prhush
   (shen.app shen.*infs*
    " inferences
"
    'shen.a)
   (stoutput))
  (shen.deref V1155 V1156)))

(DEFUN unify (V1158 V1159 V1160 V1161)
 (shen.lzy= (shen.lazyderef V1158 V1160) (shen.lazyderef V1159 V1160) V1160
  V1161))

(DEFUN shen.lzy= (V1178 V1179 V1180 V1181)
 (COND ((shen.ABSEQUAL V1179 V1178) (thaw V1181))
  ((AND (ARRAYP V1178) (NOT (STRINGP V1178)) (EQ (AREF V1178 0) 'shen.pvar))
   (bind V1178 V1179 V1180 V1181))
  ((AND (ARRAYP V1179) (NOT (STRINGP V1179)) (EQ (AREF V1179 0) 'shen.pvar))
   (bind V1179 V1178 V1180 V1181))
  ((AND (CONSP V1178) (CONSP V1179))
   (shen.lzy= (shen.lazyderef (CAR V1178) V1180)
    (shen.lazyderef (CAR V1179) V1180) V1180
    (freeze
     (shen.lzy= (shen.lazyderef (CDR V1178) V1180)
      (shen.lazyderef (CDR V1179) V1180) V1180 V1181))))
  (T 'false)))

(DEFUN shen.deref (V1183 V1184)
 (COND
  ((CONSP V1183)
   (CONS (shen.deref (CAR V1183) V1184) (shen.deref (CDR V1183) V1184)))
  (T
   (IF
    (AND (ARRAYP V1183) (NOT (STRINGP V1183)) (EQ (AREF V1183 0) 'shen.pvar))
    (LET ((Value (shen.valvector V1183 V1184)))
     (IF (shen.ABSEQUAL Value 'shen.-null-) V1183 (shen.deref Value V1184)))
    V1183))))

(DEFUN shen.lazyderef (V1185 V1186)
 (IF (AND (ARRAYP V1185) (NOT (STRINGP V1185)) (EQ (AREF V1185 0) 'shen.pvar))
  (LET ((Value (shen.valvector V1185 V1186)))
   (IF (shen.ABSEQUAL Value 'shen.-null-) V1185 (shen.lazyderef Value V1186)))
  V1185))

(DEFUN shen.valvector (V1187 V1188)
 (<-address (<-address shen.*prologvectors* V1188) (<-address V1187 1)))

(DEFUN unify! (V1189 V1190 V1191 V1192)
 (shen.lzy=! (shen.lazyderef V1189 V1191) (shen.lazyderef V1190 V1191) V1191
  V1192))

(DEFUN shen.lzy=! (V1209 V1210 V1211 V1212)
 (COND ((shen.ABSEQUAL V1210 V1209) (thaw V1212))
  ((AND
    (AND (ARRAYP V1209) (NOT (STRINGP V1209)) (EQ (AREF V1209 0) 'shen.pvar))
    (NOT (shen.wrapper (shen.occurs? V1209 (shen.deref V1210 V1211)))))
   (bind V1209 V1210 V1211 V1212))
  ((AND
    (AND (ARRAYP V1210) (NOT (STRINGP V1210)) (EQ (AREF V1210 0) 'shen.pvar))
    (NOT (shen.wrapper (shen.occurs? V1210 (shen.deref V1209 V1211)))))
   (bind V1210 V1209 V1211 V1212))
  ((AND (CONSP V1209) (CONSP V1210))
   (shen.lzy=! (shen.lazyderef (CAR V1209) V1211)
    (shen.lazyderef (CAR V1210) V1211) V1211
    (freeze
     (shen.lzy=! (shen.lazyderef (CDR V1209) V1211)
      (shen.lazyderef (CDR V1210) V1211) V1211 V1212))))
  (T 'false)))

(DEFUN shen.occurs? (V1222 V1223)
 (COND ((shen.ABSEQUAL V1223 V1222) 'true)
  ((CONSP V1223)
   (or (shen.occurs? V1222 (CAR V1223)) (shen.occurs? V1222 (CDR V1223))))
  (T 'false)))

(DEFUN identical (V1225 V1226 V1227 V1228)
 (shen.lzy== (shen.lazyderef V1225 V1227) (shen.lazyderef V1226 V1227) V1227
  V1228))

(DEFUN shen.lzy== (V1245 V1246 V1247 V1248)
 (COND ((shen.ABSEQUAL V1246 V1245) (thaw V1248))
  ((AND (CONSP V1245) (CONSP V1246))
   (shen.lzy== (shen.lazyderef (CAR V1245) V1247)
    (shen.lazyderef (CAR V1246) V1247) V1247
    (freeze (shen.lzy== (CDR V1245) (CDR V1246) V1247 V1248))))
  (T 'false)))

(DEFUN shen.pvar (V1250) (cn "Var" (shen.app (<-address V1250 1) "" 'shen.a)))

(DEFUN bind (V1251 V1252 V1253 V1254)
 (do (shen.bindv V1251 V1252 V1253)
  (LET ((Result (thaw V1254))) (do (shen.unbindv V1251 V1253) Result))))

(DEFUN fwhen (V1269 V1270 V1271)
 (COND ((EQ 'true V1269) (thaw V1271)) ((EQ 'false V1269) 'false)
  (T
   (simple-error
    (cn "fwhen expects a boolean: not " (shen.app V1269 "%" 'shen.s))))))

(DEFUN call (V1284 V1285 V1286)
 (COND
  ((CONSP V1284)
   (shen.call-help
    (shen.m_prolog_to_s-prolog_predicate (shen.lazyderef (CAR V1284) V1285))
    (CDR V1284) V1285 V1286))
  (T 'false)))

(DEFUN shen.call-help (V1287 V1288 V1289 V1290)
 (COND
  ((NULL V1288)
   (let Args (LIST V1289 V1290)
    (let NewF (shen.maplispsym V1287)
     (trap-error (APPLY NewF Args)
      (lambda E
       (COND
        ((shen.arity-error? V1287 Args)
         (shen.funcall (EVAL (shen.nest-lambda V1287 NewF)) Args))
        ((EQ NewF 'or) (shen.funcall (lambda X1 (lambda X2 (or X1 X2))) Args))
        ((EQ NewF 'and)
         (shen.funcall (lambda X1 (lambda X2 (and X1 X2))) Args))
        ((EQ NewF 'trap-error)
         (shen.funcall (lambda X1 (lambda X2 (trap-error X1 X2))) Args))
        ((shen.bad-lambda-call? NewF Args) (shen.funcall NewF Args))
        (T (shen.relay-error E))))))))
  ((CONSP V1288)
   (shen.call-help
    (let Args (LIST (CAR V1288))
     (let NewF (shen.maplispsym V1287)
      (trap-error (APPLY NewF Args)
       (lambda E
        (COND
         ((shen.arity-error? V1287 Args)
          (shen.funcall (EVAL (shen.nest-lambda V1287 NewF)) Args))
         ((EQ NewF 'or) (shen.funcall (lambda X1 (lambda X2 (or X1 X2))) Args))
         ((EQ NewF 'and)
          (shen.funcall (lambda X1 (lambda X2 (and X1 X2))) Args))
         ((EQ NewF 'trap-error)
          (shen.funcall (lambda X1 (lambda X2 (trap-error X1 X2))) Args))
         ((shen.bad-lambda-call? NewF Args) (shen.funcall NewF Args))
         (T (shen.relay-error E)))))))
    (CDR V1288) V1289 V1290))
  (T (shen.sys-error 'shen.call-help))))

(DEFUN shen.intprolog (V1291)
 (COND
  ((AND (CONSP V1291) (CONSP (CAR V1291)))
   (LET ((ProcessN (shen.start-new-prolog-process)))
    (shen.intprolog-help (CAR (CAR V1291))
     (shen.insert-prolog-variables
      (CONS (CDR (CAR V1291)) (CONS (CDR V1291) NIL)) ProcessN)
     ProcessN)))
  (T (shen.sys-error 'shen.intprolog))))

(DEFUN shen.intprolog-help (V1292 V1293 V1294)
 (COND
  ((AND (CONSP V1293) (AND (CONSP (CDR V1293)) (NULL (CDR (CDR V1293)))))
   (shen.intprolog-help-help V1292 (CAR V1293) (CAR (CDR V1293)) V1294))
  (T (shen.sys-error 'shen.intprolog-help))))

(DEFUN shen.intprolog-help-help (V1295 V1296 V1297 V1298)
 (COND
  ((NULL V1296)
   (let Args (LIST V1298 (freeze (shen.call-rest V1297 V1298)))
    (let NewF (shen.maplispsym V1295)
     (trap-error (APPLY NewF Args)
      (lambda E
       (COND
        ((shen.arity-error? V1295 Args)
         (shen.funcall (EVAL (shen.nest-lambda V1295 NewF)) Args))
        ((EQ NewF 'or) (shen.funcall (lambda X1 (lambda X2 (or X1 X2))) Args))
        ((EQ NewF 'and)
         (shen.funcall (lambda X1 (lambda X2 (and X1 X2))) Args))
        ((EQ NewF 'trap-error)
         (shen.funcall (lambda X1 (lambda X2 (trap-error X1 X2))) Args))
        ((shen.bad-lambda-call? NewF Args) (shen.funcall NewF Args))
        (T (shen.relay-error E))))))))
  ((CONSP V1296)
   (shen.intprolog-help-help
    (let Args (LIST (CAR V1296))
     (let NewF (shen.maplispsym V1295)
      (trap-error (APPLY NewF Args)
       (lambda E
        (COND
         ((shen.arity-error? V1295 Args)
          (shen.funcall (EVAL (shen.nest-lambda V1295 NewF)) Args))
         ((EQ NewF 'or) (shen.funcall (lambda X1 (lambda X2 (or X1 X2))) Args))
         ((EQ NewF 'and)
          (shen.funcall (lambda X1 (lambda X2 (and X1 X2))) Args))
         ((EQ NewF 'trap-error)
          (shen.funcall (lambda X1 (lambda X2 (trap-error X1 X2))) Args))
         ((shen.bad-lambda-call? NewF Args) (shen.funcall NewF Args))
         (T (shen.relay-error E)))))))
    (CDR V1296) V1297 V1298))
  (T (shen.sys-error 'shen.intprolog-help-help))))

(DEFUN shen.call-rest (V1301 V1302)
 (COND ((NULL V1301) 'true)
  ((AND (CONSP V1301) (AND (CONSP (CAR V1301)) (CONSP (CDR (CAR V1301)))))
   (shen.call-rest
    (CONS
     (CONS
      (let Args (LIST (CAR (CDR (CAR V1301))))
       (let NewF (shen.maplispsym (CAR (CAR V1301)))
        (trap-error (APPLY NewF Args)
         (lambda E
          (COND
           ((shen.arity-error? (CAR (CAR V1301)) Args)
            (shen.funcall (EVAL (shen.nest-lambda (CAR (CAR V1301)) NewF))
             Args))
           ((EQ NewF 'or)
            (shen.funcall (lambda X1 (lambda X2 (or X1 X2))) Args))
           ((EQ NewF 'and)
            (shen.funcall (lambda X1 (lambda X2 (and X1 X2))) Args))
           ((EQ NewF 'trap-error)
            (shen.funcall (lambda X1 (lambda X2 (trap-error X1 X2))) Args))
           ((shen.bad-lambda-call? NewF Args) (shen.funcall NewF Args))
           (T (shen.relay-error E)))))))
      (CDR (CDR (CAR V1301))))
     (CDR V1301))
    V1302))
  ((AND (CONSP V1301) (AND (CONSP (CAR V1301)) (NULL (CDR (CAR V1301)))))
   (let Args (LIST V1302 (freeze (shen.call-rest (CDR V1301) V1302)))
    (let NewF (shen.maplispsym (CAR (CAR V1301)))
     (trap-error (APPLY NewF Args)
      (lambda E
       (COND
        ((shen.arity-error? (CAR (CAR V1301)) Args)
         (shen.funcall (EVAL (shen.nest-lambda (CAR (CAR V1301)) NewF)) Args))
        ((EQ NewF 'or) (shen.funcall (lambda X1 (lambda X2 (or X1 X2))) Args))
        ((EQ NewF 'and)
         (shen.funcall (lambda X1 (lambda X2 (and X1 X2))) Args))
        ((EQ NewF 'trap-error)
         (shen.funcall (lambda X1 (lambda X2 (trap-error X1 X2))) Args))
        ((shen.bad-lambda-call? NewF Args) (shen.funcall NewF Args))
        (T (shen.relay-error E))))))))
  (T (shen.sys-error 'shen.call-rest))))

(DEFUN shen.start-new-prolog-process NIL
 (LET ((IncrementProcessCounter (INCF shen.*process-counter*)))
  (shen.initialise-prolog IncrementProcessCounter)))

(DEFUN shen.insert-prolog-variables (V1303 V1304)
 (shen.insert-prolog-variables-help V1303 (shen.flatten V1303) V1304))

(DEFUN shen.insert-prolog-variables-help (V1309 V1310 V1311)
 (COND ((NULL V1310) V1309)
  ((AND (CONSP V1310) (shen.wrapper (variable? (CAR V1310))))
   (LET ((V (shen.newpv V1311)))
    (LET ((XV/Y (subst V (CAR V1310) V1309)))
     (LET ((Z-Y (remove (CAR V1310) (CDR V1310))))
      (shen.insert-prolog-variables-help XV/Y Z-Y V1311)))))
  ((CONSP V1310) (shen.insert-prolog-variables-help V1309 (CDR V1310) V1311))
  (T (shen.sys-error 'shen.insert-prolog-variables-help))))

(DEFUN shen.initialise-prolog (V1312)
 (LET
  ((Vector
    (address-> shen.*prologvectors* V1312
     (shen.fillvector (vector 10) 1 10 'shen.-null-))))
  (LET ((Counter (address-> shen.*varcounter* V1312 1))) V1312)))

